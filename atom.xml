<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AI码师</title>
  
  <subtitle>授人以鱼不如授人以渔</subtitle>
  <link href="https://yangletec.github.io/atom.xml" rel="self"/>
  
  <link href="https://yangletec.github.io/"/>
  <updated>2021-02-28T14:37:46.171Z</updated>
  <id>https://yangletec.github.io/</id>
  
  <author>
    <name>AI码师</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yangletec.github.io/post/4a17b156.html"/>
    <id>https://yangletec.github.io/post/4a17b156.html</id>
    <published>2021-02-28T14:37:46.171Z</published>
    <updated>2021-02-28T14:37:46.171Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>性能优化｜解读面试题，彻底搞懂类加载和初始化顺序</title>
    <link href="https://yangletec.github.io/post/27c9d2d5.html"/>
    <id>https://yangletec.github.io/post/27c9d2d5.html</id>
    <published>2021-02-28T14:23:26.000Z</published>
    <updated>2021-02-28T14:38:11.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解读面试题，彻底搞懂类加载和初始化顺序"><a href="#解读面试题，彻底搞懂类加载和初始化顺序" class="headerlink" title="解读面试题，彻底搞懂类加载和初始化顺序"></a>解读面试题，彻底搞懂类加载和初始化顺序</h1><p>在高级面试过程中，始终逃不过面试官的追问三连：</p><ul><li>你知道 jvm 是怎么加载类的么？</li><li>类的初始化顺序你有了解么？</li><li>我出一个面试题，你能答出来么？</li></ul><p>三连问下来，恐怕自己已经被劝退了，有的同学肯定会学过 jvm 是如何加载类的，但是被面试官疑问，就一脸懵了，主要原因是没有掌握到精髓，没有知道其中的原理，光靠死记硬背是不行的，面试官都看在眼里的。本文将带着大家一起分析面试题，来梳理下其中主要的知识点，相信大家在看完之后，也一定会有收获的，可以彻底告别面试官的连连追问了。</p><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题 1"></a>面试题 1</h2><p>现在我们进入正题：<br>面试官直接抛过来第一道面试题，看看大家能猜出结果不</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line">public class JVMClass extends BaseCodeBlock &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子类的普通代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public JVMClass() &#123;</span><br><span class="line">        System.out.println(&quot;子类的构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void msg() &#123;</span><br><span class="line">        System.out.println(&quot;子类的普通方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void msg2() &#123;</span><br><span class="line">        System.out.println(&quot;子类的静态方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;子类的静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BaseCodeBlock bcb &#x3D; new JVMClass();</span><br><span class="line">        bcb.msg();</span><br><span class="line">    &#125;</span><br><span class="line">    Other o &#x3D; new Other();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaseCodeBlock &#123;</span><br><span class="line"></span><br><span class="line">    public BaseCodeBlock() &#123;</span><br><span class="line">        System.out.println(&quot;父类的构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void msg() &#123;</span><br><span class="line">        System.out.println(&quot;父类的普通方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void msg2() &#123;</span><br><span class="line">        System.out.println(&quot;父类的静态方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;父类的静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Other2 o2 &#x3D; new Other2();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;父类的普通代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Other &#123;</span><br><span class="line">    Other() &#123;</span><br><span class="line">        System.out.println(&quot;初始化子类的属性值&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Other2 &#123;</span><br><span class="line">    Other2() &#123;</span><br><span class="line">        System.out.println(&quot;初始化父类的属性值&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以把上面的代码拷贝到编辑器上面，执行下看看和自己预期的结果是否一致，这段代码基本上可以展示出了类加载和初始化顺序，给大家看下结果<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614522211627-d8414429-ffbc-4cc9-8f1e-b6af5c879177.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&originHeight=372&originWidth=278&size=0&status=done&style=none&width=278"><br>可以看出如果有继承父类的话，会优先去初始化父类。遵循这样一个顺序</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614522211619-17cea2c7-16fa-47ca-85f2-2e61aaf086a6.png#align=left&display=inline&height=664&margin=%5Bobject%20Object%5D&originHeight=664&originWidth=2252&size=0&status=done&style=none&width=2252"><br>父类的静态代码块-&gt;子类的静态代码块-&gt;初始化父类的属性值/父类的普通代码块(按照代码的顺序排列执行)-&gt;父类的构造方法-&gt;初始化子类的属性值/子类的普通代码块(按照代码的顺序排列执行)-&gt;子类的构造方法。<br>构造方法最后才执行。</p><h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题 2"></a>面试题 2</h2><p>面试官开始出第二题了，又抛来一段代码，细品：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo;</span><br><span class="line"></span><br><span class="line">public class JVMClass2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton1 s1 &#x3D; Singleton1.getSingleton();</span><br><span class="line">        Singleton2 s2 &#x3D; Singleton2.getSingleton();</span><br><span class="line">        System.out.println(&quot;s1:counter1 &#x3D; &quot;+ s1.counter1);</span><br><span class="line">        System.out.println(&quot;s1:counter2 &#x3D; &quot;+s1.counter2);</span><br><span class="line">        System.out.println(&quot;s2:counter1 &#x3D; &quot;+ s2.counter1);</span><br><span class="line">        System.out.println(&quot;s2:counter2 &#x3D; &quot;+s2.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Singleton1&#123;</span><br><span class="line">    private static Singleton1 singleton &#x3D; new Singleton1();</span><br><span class="line">    public static int counter1;</span><br><span class="line">    public static int counter2 &#x3D; 0;</span><br><span class="line">    public Singleton1()&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton1 getSingleton()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Singleton2&#123;</span><br><span class="line">    public static int counter1;</span><br><span class="line">    public static int counter2 &#x3D; 0;</span><br><span class="line">    private static Singleton2 singleton &#x3D; new Singleton2();</span><br><span class="line">    public Singleton2()&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton2 getSingleton()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以开动脑经，结合上面的加载顺序，来分析分析这道题的答案。<br>我们直接看运行结果<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614522211683-e18ab62f-27ee-4e7f-9c3e-be78ab0a8416.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=328&size=0&status=done&style=none&width=328"></p><p>是不是和内心预期的有点出入啊，我们按照上面的思路分析下，</p><ol><li>构造器是在所有初始化之后才执行的</li><li>那么在所有属性初始化之后，在执行构造器的时候，counter1 和 counter2 都会有默认的初始值 0，那么执行完构造器之后，counter1 和 counter2 结果肯定都是 1，</li><li>如果这样的话，Singleton2 和 Singleton1 的执行结果应该是一样的，那么为什么 Singleton2 和我们的预期一致，Singleton1 却有出入呢</li><li>我们看到他们俩唯一的区别是进行 new 实例化的位置不一样。</li><li>既然找到了不同，我们继续往下分析，我们主要分析和我们预期不一致的 Singleton1。</li><li>Singleton1 实例化是在静态变量位置上面，所有优先他们执行，所以进入构造器执行，同学们可能会有疑问了，上面不是说构造器是在最后才执行么，为什么这里会先执行呢？因为这个构造器执行是有实例化代码触发的，所以会进行内部递优先执行构造方法</li><li>进入构造放方法，这时候 counter1 和 counter2 还是保持零值（这是有虚拟机加载 class 准备阶段执行的，后面会说），执行++之后，counter1 和 counter2 都会变成 1。构造方法执行结束，进入下一步</li><li>counter1 没有被显示赋值，counter2 被重新赋值为 0，到此初始化结束。</li><li>得到 counter1 和 counter2 分别为 1 和 0</li></ol><p>到此，面试已经结束，我们现在来结合理论知识来总结下 jvm 类加载和初始化顺序。</p><p>java 类加载分为五个过程，如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614522211613-467974d3-b9bf-4530-900e-c28c1876e92d.png#align=left&display=inline&height=370&margin=%5Bobject%20Object%5D&originHeight=370&originWidth=2068&size=0&status=done&style=none&width=2068"></p><h2 id="类加载顺序"><a href="#类加载顺序" class="headerlink" title="类加载顺序"></a>类加载顺序</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol><li>文件格式的验证：</li></ol><p>验证文件格式是否按照虚拟机的规范，也就是我们前面 class 文件结构中的内容，比如这是不是一个 Class 文件（看魔数，是否位 CAFEBABE）；<br>Java 版本是否符合当前虚拟机的范围（Java 可以向下兼容，但是不能处理大于当前版本的程序）等等。</p><ol><li>元数据的验证：</li></ol><p>对 Class 文件中的元数据进行验证，是否存在不符合 Java 语义的元数据信息。这里有的朋友可能会比较疑惑，什么是元数据呢？一般情况下，一个文件中都数据和元数据。数据指的是实际数据，而元数据（Metadata）是用来描述       数据的数据。用过 Java 注解的朋友应该对元数据这种叫法并不陌生，对应的元注解，其实说的差不多都是一个意思。<br>举个例子：比如说我们定义了一个变量 int a = 1；可以理解成数据就是 1，而元数据就是描述有一个字符串变量“a”，这个“a”的类型是 int 型的，它的值也是一个 int 型的 1，这就是描述数据的数据，就是元数据。</p><ol><li>字节码的验证：</li></ol><p>通过数据流和控制流分析，来确定程序语义是否合法。<br>以数据来说，要保证类型转换是有效的；对于控制流程的代码，不能让指令跳转到其它方法的字节码指令上等……</p><ol><li>符号引用的验证：</li></ol><p>为了保证解析动作能正常完成，还需在虚拟机将符号引用转成直接引用的时候，判断其它要引用的类是否符合规定。比如，要引用的类是否能够被找到；引用的属性在对应类中是否存在，权限是否符合要求（private 的是不能访问       的）等。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>了解完加载的五大步之后，我们再看下最后一个重要的知识点，就是我们使用类的时候，什么时候会触发类的初始化呢，分为以下四种情况：</p><h2 id="什么时候会进行类的初始化"><a href="#什么时候会进行类的初始化" class="headerlink" title="什么时候会进行类的初始化"></a>什么时候会进行类的初始化</h2><ol><li>当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。</li></ol><p>今天分享的面试内容到此结束，我们下一期再见吧。文末附赠视频教程和面试资料。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12552073/1614522211667-0e455642-9c59-4cde-bb04-2b5b7c8c3baf.jpeg#align=left&display=inline&height=258&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=258&size=0&status=done&style=none&width=258"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614522211638-f9720601-574e-4542-b52d-41008e324459.png#align=left&display=inline&height=1966&margin=%5Bobject%20Object%5D&originHeight=1966&originWidth=1762&size=0&status=done&style=none&width=1762"></p><blockquote><p>微信搜一搜【乐哉开讲】关注帅气的我，回复【干货】，将会有大量面试资料和架构师必看书籍等你挑选，包括 java 基础、java 并发、微服务、中间件等更多资料等你来取哦。<br>书读的越多而不加思考，你就会觉得你知道得很多；而当你读书而思考得越多的时候，你就会越清楚地看到，你知道得很少。——伏尔泰</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解读面试题，彻底搞懂类加载和初始化顺序&quot;&gt;&lt;a href=&quot;#解读面试题，彻底搞懂类加载和初始化顺序&quot; class=&quot;headerlink&quot; title=&quot;解读面试题，彻底搞懂类加载和初始化顺序&quot;&gt;&lt;/a&gt;解读面试题，彻底搞懂类加载和初始化顺序&lt;/h1&gt;&lt;p&gt;在高</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>并发编程｜连小白都能听懂的“synchronized”关键字讲解，面试官直呼好！</title>
    <link href="https://yangletec.github.io/post/4cac77a1.html"/>
    <id>https://yangletec.github.io/post/4cac77a1.html</id>
    <published>2021-02-28T14:22:29.000Z</published>
    <updated>2021-02-28T14:38:11.495Z</updated>
    
    <content type="html"><![CDATA[<p>synchronized 有哪几种使用方式？</p><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的 class 对象</li><li>同步代码块，锁事 synchronized 括号中的对象<blockquote><p>jvm 怎么标识线程已经获取锁呢？这得要说说 java 对象头了</p></blockquote></li></ul><table><thead><tr><th>存储对象的 hashcode 或锁信息</th><th>存储到对象类型数据的指针</th><th>数组长度(如果当前对象是数组)</th></tr></thead><tbody><tr><td>Mark Word</td><td>Class Metadata Address</td><td>Array length</td></tr></tbody></table><p>注意：锁可以升级但是不能降级</p><blockquote><p>什么是偏向锁？</p></blockquote><ul><li>偏向锁的获取<ol><li> 线程 A 进入临界点前，判断对象头中 Mark Word 中是否存着指向本线程的偏向锁，如果有，则直接获取锁成功，进入临界区，如果不存在，则执行下一步</li><li> Mark word 的偏向锁表示位是否设置成 1(当前已经是偏向锁)，如果没有，则使用 CAS 竞争锁，否则</li><li> 使用 CAS 将对象头的偏向锁指向当前线程</li></ol></li><li>偏向锁的撤销<ol><li> 锁撤销只会发生在锁竞争的时候并且当前没有正在执行的字节码</li><li> 暂停拥有偏向锁的线程</li><li> 检查拥有偏向锁的进程是否存活，如果不处于存活状态，则将对象头设置为无锁状态，否则</li><li> 如果线程一直存活，则拥有偏向锁的栈会被执行，栈中的锁记录和对象头的 Mark word 要么重新偏向于其他线程，要么恢复到无无锁状态，最后唤醒暂停的线程</li></ol></li><li>关闭偏向锁<br>偏向锁在 jdk 中默认是启用的，如果你确定你的线程中会发生锁竞争，那么你可以使用如下命令关闭偏向锁<br>-XX:BiasedLockingStartupDelay = 0;</li></ul><blockquote><p>轻量级锁</p></blockquote><ul><li>轻量级锁加锁<ol><li> 线程在执行同步代码块之前，JVM 会在当前的栈桢中创建存储锁记录的空间，并将锁对象头的 Mark Word 内容复制到刚才创建的锁记录空间中，这一步叫做“Displaced Mark Word”，</li><li> 然后当前线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向当前锁记录空间的内存地址，</li><li> 如果替换成功则成功获取锁，否则表示有其他线程在竞争这把锁，则</li><li> 使用自旋的方式来获取锁。</li></ol></li><li>轻量级锁解锁<ol><li> 使用 CAS 操作将获取锁之前复制的 Mark Word 替换回锁对象头中，如果成果成功，则表示没有竞争发生，</li><li> 如果失败，锁就会膨胀成重量级锁，并且在使用自旋方式尝试获取轻量级锁的线程会被阻塞</li><li> 拥有轻量级锁的线程释放锁并唤醒等待的线程，被唤醒的线程重新争夺锁，访问临界区。</li></ol></li></ul><blockquote><p>为什么锁不能被降级<br>锁的优缺点对比</p></blockquote><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗</td><td>如果线程间存在竞争，则需要额外消耗</td><td>只有一个线程的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高程序响应速度</td><td>自旋操作，时间过长会消耗过多的 cpu</td><td>追求响应时间，同步块中的任务执行的很快，不会长时间阻塞</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗过多 cpu</td><td>线程阻塞，响应时间慢</td><td>追求吞吐量，同步块执行时间长</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12552073/1614522179335-81927717-84c1-4312-9123-ced5c5daf6e8.jpeg#align=left&display=inline&height=258&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=258&size=0&status=done&style=none&width=258"></p><blockquote><p>微信搜一搜【AI 码师】关注帅气的我，回复【干货】，将会有大量面试资料和架构师必看书籍等你挑选，包括 java 基础、java 并发、微服务、中间件等更多资料等你来取哦。<br>书读的越多而不加思考，你就会觉得你知道得很多；而当你读书而思考得越多的时候，你就会越清楚地看到，你知道得很少。——伏尔泰</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;synchronized 有哪几种使用方式？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通同步方法，锁是当前实例对象&lt;/li&gt;
&lt;li&gt;静态同步方法，锁是当前类的 class 对象&lt;/li&gt;
&lt;li&gt;同步代码块，锁事 synchronized 括号中的对象&lt;blockquote&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式｜玩转redis看这一篇就够了，轻轻松松应对各种面试难题</title>
    <link href="https://yangletec.github.io/post/1aefe554.html"/>
    <id>https://yangletec.github.io/post/1aefe554.html</id>
    <published>2021-02-28T14:21:40.000Z</published>
    <updated>2021-02-28T14:38:11.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据存储类型介绍"><a href="#数据存储类型介绍" class="headerlink" title="数据存储类型介绍"></a>数据存储类型介绍</h1><h3 id="业务数据的特殊性"><a href="#业务数据的特殊性" class="headerlink" title="业务数据的特殊性"></a>业务数据的特殊性</h3><h4 id="作为缓存使用"><a href="#作为缓存使用" class="headerlink" title="作为缓存使用"></a>作为缓存使用</h4><ul><li>原始业务功能设计<ul><li>秒杀</li><li>618 活动</li><li>双 11 活动</li><li>12306</li></ul></li></ul><h4 id="附加功能"><a href="#附加功能" class="headerlink" title="附加功能"></a>附加功能</h4><ul><li>系统功能优化升级<ul><li>单服务器升级集群</li><li>session 管理</li><li>Token 管理</li></ul></li></ul><h3 id="Redis-数据类型-5-种常用"><a href="#Redis-数据类型-5-种常用" class="headerlink" title="Redis 数据类型(5 种常用)"></a>Redis 数据类型(5 种常用)</h3><ul><li>string      string</li><li>hash      HashMap</li><li>list      LinkedList</li><li>set      HashSet</li><li>sorted_set      TreeSet</li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>get key</li><li>set key</li><li>del [key]</li><li>mset key1 value1 key2 value2</li><li>mget key1 key2</li><li>strlen key</li><li>append key value</li></ul><h6 id="单数据操作与多数据操作的选择之或？"><a href="#单数据操作与多数据操作的选择之或？" class="headerlink" title="单数据操作与多数据操作的选择之或？"></a>单数据操作与多数据操作的选择之或？</h6><ul><li>比较发送与执行时间消耗时间对比</li></ul><h6 id="string-数据类型的扩展操作"><a href="#string-数据类型的扩展操作" class="headerlink" title="string 数据类型的扩展操作"></a>string 数据类型的扩展操作</h6><ul><li>设置数值数据新增加指定范围的值，可以使用负号作为递减操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br><span class="line">incrby key increment</span><br><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure><ul><li>设置数值数据新减去指定范围的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decr key</span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure><ul><li>设置数值有效期 解决时效性控制的操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key second value   秒</span><br><span class="line">psetex key milliseconds value 毫秒</span><br></pre></td></tr></table></figure><h6 id="string-类型数据操作时的注意事项"><a href="#string-类型数据操作时的注意事项" class="headerlink" title="string 类型数据操作时的注意事项"></a>string 类型数据操作时的注意事项</h6><ul><li>设置数值有效期 解决时效性控制的操作<ol><li> 数据未获取到</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（nil）等于 null</span><br></pre></td></tr></table></figure><ol><li> 数据最大存储量 <code>512m</code></li><li> 数据计算最大范围 (java 中的 long 的最大值) <code>9223372036854775807</code></li></ol><h6 id="string-类型应用场景"><a href="#string-类型应用场景" class="headerlink" title="string 类型应用场景"></a>string 类型应用场景</h6><ul><li>在 redis 中存储用户信息<ol><li> user<img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f194.svg#align=left&display=inline&height=18&margin=%5Bobject%20Object%5D&originHeight=150&originWidth=150&status=done&style=none&width=18">333:fans -&gt; 11111   数值</li><li> user<img src="https://gw.alipayobjects.com/os/lib/twemoji/11.2.0/2/svg/1f194.svg#align=left&display=inline&height=18&margin=%5Bobject%20Object%5D&originHeight=150&originWidth=150&status=done&style=none&width=18">333 -&gt; {id:333,fans:333} json</li></ol></li><li>redis 应用于各种结构性和非结构性高热度数据访问的加速</li><li>key 的设置约定   表名:主键名:主键值:字段名</li></ul><h3 id="hash-底层使用哈希表结构存储"><a href="#hash-底层使用哈希表结构存储" class="headerlink" title="hash 底层使用哈希表结构存储"></a>hash <code>底层使用哈希表结构存储</code></h3><h6 id="hash-存储结构优化"><a href="#hash-存储结构优化" class="headerlink" title="hash 存储结构优化"></a>hash 存储结构优化</h6><ul><li>如果 field 字段数量少，使用数据数组进行存储</li><li>如果 field 字段数量多，存储结构使用 hashmap</li></ul><h6 id="hash-类型数据的基本操作"><a href="#hash-类型数据的基本操作" class="headerlink" title="hash 类型数据的基本操作"></a>hash 类型数据的基本操作</h6><ul><li>添加/修改数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure><ul><li>获取数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line">hgetall key</span><br></pre></td></tr></table></figure><ul><li>删除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field [field2]</span><br></pre></td></tr></table></figure><ul><li>添加/修改多个数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field1 value1 field2 value2</span><br></pre></td></tr></table></figure><ul><li>获取多个数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key filed1 field2</span><br></pre></td></tr></table></figure><ul><li>获取 hash 表中字段的数量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure><ul><li>获取 hash 表中是否存在指定字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure><h6 id="hash-数据类型的扩展操作"><a href="#hash-数据类型的扩展操作" class="headerlink" title="hash 数据类型的扩展操作"></a>hash 数据类型的扩展操作</h6><ul><li>获取 hash 表中所有的字段名和值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  hkeys key</span><br><span class="line">hvalues key</span><br></pre></td></tr></table></figure><ul><li>设置值自增</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   hincrby key increment</span><br><span class="line">hincrbyfloat key increment</span><br></pre></td></tr></table></figure><ul><li>设置值字符，存在则设置失败，不存在则设置成功</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key field value</span><br></pre></td></tr></table></figure><h6 id="hash-数据类型注意事项"><a href="#hash-数据类型注意事项" class="headerlink" title="hash 数据类型注意事项"></a>hash 数据类型注意事项</h6><ul><li>hash 类型 value 只能存字符串</li><li>每个 hash 可以存储 2^32-1 个键值对</li><li>hash 可以灵活操作属性，虽然可以作为对象使用，但是不能滥用</li><li>hgetall key 获取 hash 内的键值对</li></ul><h6 id="hash-数据类型应用场景"><a href="#hash-数据类型应用场景" class="headerlink" title="hash 数据类型应用场景"></a>hash 数据类型应用场景</h6><ul><li>购物车</li></ul><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h6 id="list-类型数据的基本操作-链表"><a href="#list-类型数据的基本操作-链表" class="headerlink" title="list 类型数据的基本操作 链表"></a>list 类型数据的基本操作 链表</h6><ul><li>添加/修改数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      lpush key value [value]</span><br><span class="line">rpush key value [value]</span><br></pre></td></tr></table></figure><ul><li>获取数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  lrange key start stop (0,-1获取全部)</span><br><span class="line">lindex key index</span><br><span class="line">llen key</span><br></pre></td></tr></table></figure><ul><li>获取并移除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure><ul><li>规定时间内获取并移除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   blpop key [key] timeout (单位为秒)</span><br><span class="line">brpop key [key] timeout (单位为秒)</span><br></pre></td></tr></table></figure><h6 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h6><ul><li>删除指定元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure><h6 id="list-数据类型注意事项"><a href="#list-数据类型注意事项" class="headerlink" title="list 数据类型注意事项"></a>list 数据类型注意事项</h6><ul><li>list 数据保存的数据都是 string 类型，最多 2^32-1 个元素</li><li>list 常被用作队列</li><li>list 结束索引为-1</li><li>list 可以进行数据分页操作 第一页来自 list，第二页及更多来自数据库</li></ul><h6 id="业务场景-1"><a href="#业务场景-1" class="headerlink" title="业务场景"></a>业务场景</h6><ul><li>信息管理</li><li>多路信息汇总</li><li>最新消息</li></ul><h3 id="set-无序"><a href="#set-无序" class="headerlink" title="set 无序"></a>set 无序</h3><h6 id="set-类型数据的基本操作"><a href="#set-类型数据的基本操作" class="headerlink" title="set 类型数据的基本操作"></a>set 类型数据的基本操作</h6><ul><li>添加数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key memeber1 [member]</span><br></pre></td></tr></table></figure><ul><li>获取全部数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure><ul><li>删除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key member1 [member]</span><br></pre></td></tr></table></figure><h6 id="set-类型数据的扩展操作"><a href="#set-类型数据的扩展操作" class="headerlink" title="set 类型数据的扩展操作"></a>set 类型数据的扩展操作</h6><ul><li>随机获取几个元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key count</span><br></pre></td></tr></table></figure><ul><li>随机获取几个元素 并删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key count</span><br></pre></td></tr></table></figure><ul><li>获取元素个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure><ul><li>求两个集合的交并差</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinter key key2</span><br><span class="line">sunion key1 key2</span><br><span class="line">sdiff key1 key2</span><br></pre></td></tr></table></figure><ul><li>求两个集合的交并差 并存到指定集合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore desc key key2</span><br><span class="line">sunionstore desc key1 key2</span><br><span class="line">sdiffstore desc key1 key2</span><br></pre></td></tr></table></figure><ul><li>将指定数据从原始集合移动到目标集合中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove source desc member</span><br></pre></td></tr></table></figure><ul><li>查看数据是否存在</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key memeber</span><br></pre></td></tr></table></figure><h6 id="业务场景-2"><a href="#业务场景-2" class="headerlink" title="业务场景"></a>业务场景</h6><ul><li>随机推荐和抽奖等</li></ul><h3 id="zset-有序"><a href="#zset-有序" class="headerlink" title="zset 有序"></a>zset 有序</h3><h6 id="zset-类型数据的基本操作"><a href="#zset-类型数据的基本操作" class="headerlink" title="zset 类型数据的基本操作"></a>zset 类型数据的基本操作</h6><ul><li>添加数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score memeber1</span><br></pre></td></tr></table></figure><ul><li>查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrange key start stop [withscores]</span><br></pre></td></tr></table></figure><ul><li>查询 反序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrange key start stop [withscores]</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key memeber [member]</span><br></pre></td></tr></table></figure><h3 id="数据类型实战"><a href="#数据类型实战" class="headerlink" title="数据类型实战"></a>数据类型实战</h3><ul><li>限流 如果限流为 100 则把最大值-100，利用异常做限制，不需要每次进行判断</li></ul><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li>删除 key  del key</li><li>key 的类型 type key</li><li>key 是否存在 exists key</li><li>为 key 设置有效期</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> expire key  seconds</span><br><span class="line">pexpire key millseconds</span><br><span class="line"> expireeat key timestamp</span><br><span class="line"> pexpireeat key mill-timestamp</span><br></pre></td></tr></table></figure><ul><li>获取 key 有效时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure><ul><li>切换 key 从临时转为永久</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></table></figure><ul><li>查询模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keys *  匹配所有</span><br><span class="line">keys ?lezai 匹配单个字符</span><br><span class="line">keys a[abc]  匹配aa ab ac</span><br></pre></td></tr></table></figure><ul><li>key 重命名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename key new key</span><br><span class="line">renamenx key newkey 新key不存在则成功</span><br></pre></td></tr></table></figure><ul><li>对所有 key 里面的内容排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort key</span><br></pre></td></tr></table></figure><ul><li>切换数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select dbindex</span><br><span class="line">ping pong</span><br></pre></td></tr></table></figure><ul><li>数据库移动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv key  dbindex</span><br><span class="line">flushdb 删除当前库数据</span><br><span class="line">flushall 清除所有数据</span><br></pre></td></tr></table></figure><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><ul><li>客户端连接 redis</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连接 Jedis jedis &#x3D;new Jedis(&quot;127.0.0.1&quot;,6379)</span><br><span class="line">设置 jedis.set(&quot;name&quot;,123)</span><br><span class="line">获取 jedis.get(&quot;name&quot;)</span><br></pre></td></tr></table></figure><h3 id="Linux-安装-redis"><a href="#Linux-安装-redis" class="headerlink" title="Linux 安装 redis"></a>Linux 安装 redis</h3><ul><li>下载 wget <a href="http://download.redis.io/releases/redis-4.0.10.tar.gz">http://download.redis.io/releases/redis-4.0.10.tar.gz</a></li><li>解压 tar-xvzf redis-4.0.10.tar.gz</li><li>编译 make</li><li>安装 make install</li><li>指定端口启动 redis-server –port 9999</li><li>指定端口连接 redis-cli -p 9999</li><li>指定配置文件启动 redis-server conf/redis.conf</li></ul><h5 id="redis-服务端基本配置"><a href="#redis-服务端基本配置" class="headerlink" title="redis 服务端基本配置"></a>redis 服务端基本配置</h5><ul><li>daemonize yes 以守护进程方式启动</li><li>port 6379 设置启动端口</li><li>dir “/redis/data” 设置当前服务文件保存位置</li><li>logfile “744.log” 设置日志文件名</li></ul><h5 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h5><h6 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h6><ul><li>save 手动执行保存一次快照信息</li><li>相关配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.rdb 设置本地数据库文件 默认为dump.rdb 一般设置为 dump-端口号.rdb</span><br><span class="line">rdbcompression yes 是否启动压缩</span><br><span class="line">rdbchecksum yes 是否对库文件进行校验</span><br></pre></td></tr></table></figure><ul><li>bgsave 使用 fork 函数生成一个子进程，在子进程中执行</li><li>rdb 自动启动定时保存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置信息 save second changenum</span><br><span class="line">save 900 1  900 秒内有一个key变化</span><br><span class="line">save 60 3 60秒内有3个key变化</span><br><span class="line">save 10 6</span><br></pre></td></tr></table></figure><h6 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h6><h6 id="写数据的三种策略"><a href="#写数据的三种策略" class="headerlink" title="写数据的三种策略"></a>写数据的三种策略</h6><ul><li>always 每次操作都同步写入到 aof 中，数据零误差 性能低</li><li>everysec 每秒 将缓冲区的指令同步到 aof 中，系统宕机只会丢失一秒的数据</li><li>no 系统控制 不可控</li></ul><h6 id="AOF-功能开启"><a href="#AOF-功能开启" class="headerlink" title="AOF 功能开启"></a>AOF 功能开启</h6><ul><li>appendonly yes | no   开启持久化 默认不开启</li><li>appendfsync always | everysec | no  AOF 策略</li><li>appendfilename fielname</li></ul><h6 id="AOF-重写-重写规则"><a href="#AOF-重写-重写规则" class="headerlink" title="AOF 重写 重写规则"></a>AOF 重写 重写规则</h6><ul><li>进程内已超时的数据不再重写</li><li>忽略无效指令</li><li>对同一数据的多条写合并为一条</li><li>bgrewriteaof 重写 aof 指令</li></ul><h6 id="AOF-与-RDB-选择"><a href="#AOF-与-RDB-选择" class="headerlink" title="AOF 与 RDB 选择"></a>AOF 与 RDB 选择</h6><ul><li>数据很敏感 使用 aof</li><li>数据间断性呈现 RDB</li><li>综合方案 同时开启 rdb+aof</li></ul><h1 id="Redis-高级操作"><a href="#Redis-高级操作" class="headerlink" title="Redis 高级操作"></a>Redis 高级操作</h1><h4 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h4><h5 id="事务的基本操作"><a href="#事务的基本操作" class="headerlink" title="事务的基本操作"></a>事务的基本操作</h5><ul><li>开启事务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi 设定事务的开启 执行指令后，全都加入到事务中</span><br></pre></td></tr></table></figure><ul><li>执行事务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 设定事务的结束，同时执行事务，与multi成对出现</span><br></pre></td></tr></table></figure><ul><li>取消事务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard 取消事务</span><br></pre></td></tr></table></figure><ul><li>注意</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事务出错不能回滚，产生的数据不会回滚</span><br></pre></td></tr></table></figure><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul><li>watch key1 key2 …</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">监控某个key，需要在事务外面使用，如果key被外部修改了，则终止事务的执行</span><br></pre></td></tr></table></figure><ul><li>unwatch</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取消对事务的监控</span><br></pre></td></tr></table></figure><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li>setnx key value</li></ul><h4 id="解决死锁-添加时效性"><a href="#解决死锁-添加时效性" class="headerlink" title="解决死锁 添加时效性"></a>解决死锁 添加时效性</h4><h4 id="Redis-删除策略"><a href="#Redis-删除策略" class="headerlink" title="Redis 删除策略"></a>Redis 删除策略</h4><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><ul><li>创建一个定时器，当 key 设置有过期时间，且过期时间到达，由定时器执行对键的删除操作</li><li>牺牲 CPU 保证内存空间 CPU 空闲 内存紧张</li></ul><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><ul><li>在获取数据的时候，如果未过期，返回数据，过期了，删除，返回不存在</li><li>牺牲存储保证 CPU 存储空间足 CPU 紧张</li></ul><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><blockquote><p>定期删除策略是怎么实现的？通过 activeExpireCycle 函数，serverCron 函数执行时，activeExpireCycle 函数就会被调用，规定的时间里面分多次遍历服务器的 expires 字典随机检查一部分 key 的过期时间，并删除其中的过期 key<br>例如 Redis 每秒处理：</p><ol><li>测试随机的 20 个 keys 进行相关过期检测。</li><li>删除所有已经过期的 keys。</li><li>如果有多于 25%的 keys 过期，重复步奏 1.</li></ol></blockquote><h4 id="Redis-逐出算法"><a href="#Redis-逐出算法" class="headerlink" title="Redis 逐出算法"></a>Redis 逐出算法</h4><ul><li>在执行每一个命令前，都调用 freememoryifneed,内存不足，需要临时删除一些数据清理空间</li><li>maxmemory 最大内存</li><li>maxmemory-samples 随机选择</li><li>maxmemory-policy</li><li>有效期的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile-lru 最近最少使用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile-lfu 最近使用次数最少</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile-ttl 挑选将要过期的数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile-random 任意选择数据淘汰</span><br></pre></td></tr></table></figure><ul><li>所有数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allkeys-lru 最近最少使用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allkeys-lfu 最近使用次数最少</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allkeys-random 任意选择数据淘汰</span><br></pre></td></tr></table></figure><ul><li>no-enviction</li></ul><h4 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h4><h5 id="bitmaps"><a href="#bitmaps" class="headerlink" title="bitmaps"></a>bitmaps</h5><ul><li>setbits key offset value</li><li>getbits key offset</li><li>bitop [and or not xor] destkey key1 key2 对多个 key 组合操作，保存到 destkey 中</li><li>bitcount key [start end] 统计为 1 的数量</li></ul><h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><ul><li>pfadd key element ..</li><li>pfcount key</li><li>pfmerge destkey sourcekey1 sourcekey2</li><li>相关说明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于基数统计，不是集合，不保存数据，只记录数量而不是具体数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心是基数估算，最终数值存在一定误差</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">误差范围：0.81%</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">占用12k</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd 不是一次性分配12看，而是随基数增大而增加空间</span><br></pre></td></tr></table></figure><h5 id="Geo-距离计算"><a href="#Geo-距离计算" class="headerlink" title="Geo 距离计算"></a>Geo 距离计算</h5><ul><li>geoadd key longitude latitude member … 添加坐标</li><li>geopos key member … 获取坐标</li><li>geodist key member1 member2 unit 获取坐标点距离</li><li>georadius key longitude latitude radius unit   根据坐标求范围内的数据</li><li>georadiusbymember key memeber radius unit 根据点求范围内的数据</li></ul><h1 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h1><h2 id="主从复制简介"><a href="#主从复制简介" class="headerlink" title="主从复制简介"></a>主从复制简介</h2><h3 id="互联网“三高”"><a href="#互联网“三高”" class="headerlink" title="互联网“三高”"></a>互联网“三高”</h3><ul><li>高性能</li><li>高并发</li><li>高可用  5 个 9 99.999%</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>建立连接</li><li>数据同步(复制数据)</li><li>反复同步(命令传播)</li><li>建立连接阶段工作流程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 发送指令 slaveof ip port</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 接收到指令，响应对方</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.保存master的ip与端口 masterip masterport</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.根据连接保存的信息创建与master的socket</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.向master周期发送ping，master相应pong</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.slave 发送author password</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.验证授权</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.发送指令replyconfiglistening-port port-num</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9.保存slave端口号</span><br></pre></td></tr></table></figure><ul><li>连接的三种方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.slaveof if ip port</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.slave启动时 带参数 --slaveof masterip masterport</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.服务器配置 slaveof if ip port</span><br></pre></td></tr></table></figure><ul><li>数据同步阶段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全量复制开始</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">①发送指令 psync2 请求同步数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">②master执行bgsave</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">③第一个slave建立连接，创建命令缓冲区</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">④生成rdb，通过socket发给slave</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⑤vslave接受rdb，清空数据，执行rdb文件恢复</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⑥发送命令，告知已经恢复完成</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全量复制结束</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">部分复制开始</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⑦发送复制缓冲区指令信息</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⑧接受指令，执行bgrewriteeaof，恢复数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">部分复制结束</span><br></pre></td></tr></table></figure><ul><li>命令传播阶段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复制缓冲区 偏移量 字节值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工作原理： 通过offset区分不同的slave当前数据传播的差异，maste记录已发送的信息对应的offset，slave记录已经接受的offset</span><br></pre></td></tr></table></figure><h4 id="数据同步-全"><a href="#数据同步-全" class="headerlink" title="数据同步(全)"></a>数据同步(全)</h4><ul><li><p>slave 发送指令 psync ？-1</p></li><li><p>master 收到发现没有偏移量，则使用 bgsave 生成 rdb 文件，记录当前的复制偏移量 offset</p></li><li><p>发送 fullresync runid offset，通过 socket 发送给 slave，期间收到客户端命令，offset 发生变化</p></li><li><p>收到 + fullresync 保存 master 的 runid 和 offset，清空当前数据，接受 rdb 文件，执行恢复</p></li><li><p>发送命令 psync2 runid offset</p></li><li><p>master 接受到命令，判定 runid 是否匹配，判定 offset 是否在缓冲中</p></li><li><p>如果 runid 和 offset 不匹配，则执行全量复制</p></li><li><p>如果 runid 和 master 校验通过，offset 和 offset 相同，忽略</p></li><li><p>如果 runid 和 master 校验通过，offset 和 offset 不相同，     发送 continue offset，通过 socket 发送缓冲区中 offset 到 offset 的数据</p></li><li><p>slave 接收到 continue，保存 master 的 offset，接受信息后，执行 bgrewriteaof,恢复数据</p></li><li></li><li><p>主从复制参数注意</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">① slave-server-stable-data yes|no 同步过程，开启或关闭对外写操作</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">②repl-backlog-size 1mb 设置master指令缓冲区大小，</span><br></pre></td></tr></table></figure><ul><li>主从复制常见问题频繁全量复制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">①缓冲区太小 导致offset不匹配 解决:缓冲区设置大点</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">②maset宕机重启，导致runid和offset丢失，全量复制 master执行shutdown 时，将runid和offset进行保存，重启时进行读取</span><br></pre></td></tr></table></figure><ul><li>频繁网络中断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">① 执行命令一直阻塞耗时  设置超时时间</span><br></pre></td></tr></table></figure><ul><li>数据不一致</li></ul><h2 id="哨兵简介"><a href="#哨兵简介" class="headerlink" title="哨兵简介"></a>哨兵简介</h2><blockquote><p>哨兵是一个分布式系统，用于对主从结构中的每台服务器做监控，当出现故障通过投票随机选择新的 master 并将所有的 slave 连接到信息 master</p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>监控</li><li>通知</li><li>自动故障转移</li></ul><h3 id="启用哨兵模式"><a href="#启用哨兵模式" class="headerlink" title="启用哨兵模式"></a>启用哨兵模式</h3><ul><li>启动哨兵</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel redis-sentinel.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配置文件中配置 主redis节点</span><br></pre></td></tr></table></figure><h3 id="哨兵工作原理"><a href="#哨兵工作原理" class="headerlink" title="哨兵工作原理"></a>哨兵工作原理</h3><h4 id="监控阶段"><a href="#监控阶段" class="headerlink" title="监控阶段"></a>监控阶段</h4><ul><li>用于同步各个节点的状态信息<ul><li>获取 sentinel 的状态(是否在线)</li><li>获取 master 状态</li><li>获取所有 slave 状态</li><li>master 保存 sentinel 信息，作用是让其他 sentinel 来发现其他的 sentinel，建立订阅通道</li></ul></li></ul><h4 id="通知阶段"><a href="#通知阶段" class="headerlink" title="通知阶段"></a>通知阶段</h4><ul><li>每个 sentinel 进行互通</li></ul><h4 id="故障转移阶段"><a href="#故障转移阶段" class="headerlink" title="故障转移阶段"></a>故障转移阶段</h4><ul><li>sentinel 发现 master 关挂了，标记 master 为主观下线，然后发送命令给奇特哨兵，其他哨兵也会去看看状态，如果一半以上的哨兵认为 master 挂了，那就直接标记为客观下线，执行故障转移操作</li><li>sentinel 通过竞选，然后获得此次处理 master 的权利，成为领头 sentinel<ul><li>去除不在线的</li><li>去除响应慢的</li><li>与原 master 断开时间久的</li><li>优先原则<ul><li>优先级</li><li>offset</li><li>runid</li></ul></li></ul></li><li>发送指令<ul><li>向新的 master 发送 slave no one 指令</li><li>向其他 slave 发送 slaveof 新的 ip 端口</li></ul></li></ul><h2 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h2><h3 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h3><ul><li>通过算法设计，计算出 key 应该保存的位置</li><li>将所有的存储空间分割成 16384 份，每台主机保存一部分代表的是一个存储空间，不是一个 key 的保存空间</li><li>将 key 按照计算的结果放到对应的存储空间</li></ul><h3 id="集群内部通讯设计"><a href="#集群内部通讯设计" class="headerlink" title="集群内部通讯设计"></a>集群内部通讯设计</h3><ul><li>各个节点相互通信，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体位置</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>cluster-enabled yes</li><li>cluster-config-file node-6379.conf</li><li>cluster-node-timeout 10000</li><li>在 src 下执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;redis-trib.rb create --replicas 1(一个master,一个slave,2 一个master两个slave)  主[...] 从[...]</span><br></pre></td></tr></table></figure><ul><li>连接集群客户端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c</span><br></pre></td></tr></table></figure><h1 id="企业级解决方案"><a href="#企业级解决方案" class="headerlink" title="企业级解决方案"></a>企业级解决方案</h1><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><blockquote><p>系统启动前，提前将相关的缓存数据直接加载到缓存系统，避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的数据</p></blockquote><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote><p>缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力，如能够有效避免过期时间集中吗，可以有效解决雪崩现象的出现，配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整</p></blockquote><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote><p>单个高热数据过期的瞬间，数据访问量比较大，未命中 redis，引发了大量对同一数据的数据库访问，导致对数据库服务器造成压力，对应策略应该业务数据分析与预防上进行，配合运行监控测试与即时调整策略，毕竟单个 key 过期监控难度高，配合雪崩处理策略即可，定时刷新、二级缓存、加锁</p></blockquote><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote><p>访问不存在的数据，跳过了合法数据的 redis 数据缓存阶段，每次访问数据库，造成对数据库的压力</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>缓存 null</li><li>key 加密</li><li>实时监控</li><li>白名单策略  bitmaps(效率低)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据存储类型介绍&quot;&gt;&lt;a href=&quot;#数据存储类型介绍&quot; class=&quot;headerlink&quot; title=&quot;数据存储类型介绍&quot;&gt;&lt;/a&gt;数据存储类型介绍&lt;/h1&gt;&lt;h3 id=&quot;业务数据的特殊性&quot;&gt;&lt;a href=&quot;#业务数据的特殊性&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>源码阅读｜怒肝了9道 HashMap经典面试题，需要的快速来取（不包邮哦）</title>
    <link href="https://yangletec.github.io/post/10bc2040.html"/>
    <id>https://yangletec.github.io/post/10bc2040.html</id>
    <published>2021-02-28T14:21:00.000Z</published>
    <updated>2021-02-28T14:38:11.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>促使自己开始研究源码的原因主要有两个，第一个是在面试高级工程师的时候，源码这块是必问的，第二个原因是现在框架是越来越多，也没有太多精力去学习，于是就准备开始研究各种底层知识，看看那些底层大佬们是如何写代码，这是踏出的第一步，后面会有越来越多的源码学习经验和大家一起分享，希望大家能够提出宝贵的意见。话不多说，直接进入我们今天的主题</p></blockquote><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><table><thead><tr><th>开发工具</th><th>JDK 版本</th></tr></thead><tbody><tr><td>IDEA 2020</td><td>JDK1.8</td></tr></tbody></table><h2 id="抛砖引玉"><a href="#抛砖引玉" class="headerlink" title="抛砖引玉"></a>抛砖引玉</h2><p>首先给大家呈上几道经典的有关 hashmap 1.8 的面试题？</p><ol><li>HashMap 的初始容量为什么是 2 的幂次方？</li><li>HashMap 在什么时候会进行扩容？</li><li>HashMap 是如何进行扩容的？</li><li>HashMap 底层数据结构？</li><li>HashMap1.8 为什么引入红黑树？</li><li>HashMap 什么时候会将链表转换成红黑树？</li><li>HashMap 在多线程情况下会出现什么？</li><li>能说说 HashMap 的 hash 算法么？</li><li>HashMap 是如何定位到 key 所在数组上的位置的?</li></ol><p>先说这么多吧，相信大家应该都会被问过这些问题，会不会很惊讶，就一个 hashmap 都能整出这么多面试问题？接下来我会通过本篇文章带着大家一起解读 hashmap 的这些骚操作，大家看完之后，上面的这些面试题都会知道该如何解答了，我们开始吧~</p><h4 id="在讲代码之前我想先和大家说下-hashmap-里面的一个数据结构"><a href="#在讲代码之前我想先和大家说下-hashmap-里面的一个数据结构" class="headerlink" title="在讲代码之前我想先和大家说下 hashmap 里面的一个数据结构"></a>在讲代码之前我想先和大家说下 hashmap 里面的一个数据结构</h4><ol><li>首先 hashmap 底层是一个数据结构，为什么要用数组呢，因为他查找非常的快，于是刚开始他长这样,他的初始长度是 16<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614522069027-0ecc0581-c484-4636-8036-4d0e59f1764e.png#align=left&display=inline&height=128&margin=%5Bobject%20Object%5D&originHeight=128&originWidth=775&size=0&status=done&style=none&width=775"></li><li>然后我插入一个 key，他是怎么计算到自己的位置的呢，通过计算他的 hash 码，得到一个整数，然后和 16 取模，就能够将数据散列到 0-15 的位置了啊，但是 jdk 会用一个更加牛逼的方法去算出这个位置，后面我会说到的，看完之后，你会觉得算法真香。</li><li>当有越来越多的数据存进来之后，发现我的那个位置被人占用了，那可咋办呢，我又不能覆盖它吧，然后就有了链表这个新的成员加入，先看下链表和数组的结合<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614522069078-fbdce042-976e-4b3d-b6b7-c6c4aa0789af.png#align=left&display=inline&height=485&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=802&size=0&status=done&style=none&width=802"></li><li>也就是说当位置相同的时候，所有的数据都会以链表的形式在那个位置一直往下接，就形成了上面这样的形式</li><li>加入链表之后，我们的数据存储问题是解决了，但是当这个链表越来越长的时候，我们找起来就费劲了，我们知道链表结构增加和删除是很快的，但是查找的复杂度就是 o(n)了，得挨个遍历。所以有必要引入新的成员了，红黑树</li><li>红黑树是平衡二叉树的一种实现方式，数据结构这块后续会有相关的文章进行讲解，那我们就来看下引入红黑树之后，是怎样一个组合呢<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614522069092-62f2da93-1daa-4ee3-b3f9-a1d4404166af.png#align=left&display=inline&height=486&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=899&size=0&status=done&style=none&width=899"><br>好的，hashmap 结构这块我已经和大家大概的讲完了，下面就让我们一步一步分析代码，来解决我们心中的疑惑吧！</li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>一个简单地 main 方法，然后跟着这个方法，我们调到 map 的世界里面去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// write your code here</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">27</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;乐哉开讲&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先进入到 new HashMap，看看构造器都给我们做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到他又调用了另外一个构造方法，并且又调用了另外一个构造方法<br>DEFAULT_LOAD_FACTOR 这个就是一个负载因子 0.75</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来分下这段代码，</p><ol><li>判断我们设置的初始容量是否合法</li><li>判断初始容量是否大于最大容量 MAXIMUM_CAPACITY = 1 &lt;&lt; 30;一般都不会大于这个最大值得，如果大于，就用这个最大值作为初始容量</li><li>判断负载因子是否合法，后面讲扩容得地方的时候再说这个负载因子是用来干嘛的</li><li>tableSizeFor 是为了计算出 大于等于这个初始容量的最小二次幂，如 15 的最小二次幂为 16 7 的最小二次幂是 8，看下具体是如何实现的，有兴趣的话可以跑下这段代码，看看是不是这样的，所以最终 map 的初始容量都是 2 的幂次方，并不一定是我们设置的数值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器分析完之后，我们在来到开始的地方，执行 put 方法，我们点进去看下，这里面是我们这次讲的核心的地方，大家认真看下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 put 方法是去调用 putVal 方法去执行 put 逻辑的，先不跟进去看，我们会看到，这里会将 key 做一个 hash 运算，看看上面的面试题 8，是不是也说到这个了，我们就点进去看下，这个 hash 他做了什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家会不会很失望，这里面只有三行代码，能做什么呢？虽然只有只有三行代码，但是这里减小了 hash 碰撞的机会，什么叫 hash 碰撞呢，就是我们刚开始的时候提到的有些数据得到了相同的下标，然后会以链表的形式存储，会导致链表过长，这里就是为了让 hash 的更加均匀，而采取的一些手段，我们来分析下代码</p><ol><li>key 如果为空的话，直接返回 hash 为 0</li><li>key 进行 hashcode 的话，会得到一串整数，</li><li>我们知道整形是占用四个字节，占用 32 个 bit，我们将前 16 个作为高位，后 16 个作为低位，然后将 32 个 bit 右移 16，是不是就能得到高 16 位的值，然后再讲高位和低位进行疑惑，得到一个新的二进制，为什么这么做呢，因为这样能够在计算元素下标的时候，能够让 hash 的高位和低位都能参与进行来，减少碰撞的概率</li><li>返回新的 hashcode<br>hashcode 计算完之后，我们再回到上一个方法 putVal</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>数组初始化</strong></p><p>这个方法是很长的，大家需要认真的慢慢的看完，我们从第一行开始进行解析 5. 首先定义一个 Node 节点，和一个 Node 数组 6. 接着判断 table 是否为空或者数组长度是否为 0 ，这个 table 是什么呢，这个 table 就是存放你创建过得 Node 数组，如果你第一次 put 操作的话，这个就是空的，第二次进来就是有内容的 7.假如我们是第一次进来，他会给我们进行 resize 操作，也就是初始化一个长度的 Node 数组，我们点进去看下，他都做了什么？顺便说下，当数组进行扩容的时候也会进入到这个 resize 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码写的真长。。。，不过没关系，我们今天就是来一探究竟的，我们一步一步往下看 7. 首先把 resize 之前的 Node 数组复制给 oldTab,保存旧的数组长度和旧的阈值(负载因子*数组长度) 8. 接着判断旧的数组容量是否是大于 0（扩容的话会进入这个判断条件），如果是大于 0 的话就判断是否大于最大的容量 MAXIMUM_CAPACITY，如果大于的话，会给阈值赋值为这个最大容量，返回 oldtab，如果旧数组的容量没有超过这个最大容量，则进行两倍扩容，阈值也会进行扩容 9. 如果旧的阈值大于 0，则将旧的阈值作为新的数组的大小，这一步我理解的是第一次构造 map 的时候不是设置了一个初始容量，然后转换为了一个二次幂，这里就是用那个值来初始化一个 Node 数组 10.如果旧的阈值等于 0 的话，那就会使用 map 默认的初始容量 16 和负载因子 0.75 来计算数组的容量和阈值大小， 10. 为什么最后又要判断下 newThr == 0 呢，因为这个如果为的话，肯定是第一次初始化数组的时候，他这个阈值是没有计算的，所以需要重新计算下。 11. 到目前为止，新的数组已经扩展或初始画好了 12. 再次判断 if (oldTab != null) ，如果旧的数组不为空的话，说明就是扩容，如果为空则可以直接返回这个数组了，不为空的话，则需要进行扩容后的数据迁移的工作了<br>数据迁移 13. 遍历所有旧数组中的元素 14. 判断当前元素是否为空，不为空才进行数据迁移 15. 接下来会有三个判断，作用分别为 判断是否是单个节点，判断是否是红黑树节点，判断是否是链表 16. 首先判断如果是单个节点，则 通过 e 的 hash 值和新的容量-1 进行与运算，会得到这个元素在新数组中的索引位置，还记得我们前面说过 jdk 用了一个比较厉害的定位元素位置的方法么，这里就是他的实现过程<br>假如我们有一个数值，我们想让他在 0-15 中间进行散列，我们想到使用模运算 %16,这里给大家介绍另外一种方法，假如是 19 ，16 取模之后，会是 3，如果将 19&amp; （16-1）,计算之后也是 3 后者效率会更高的，所以 jdk 采用后面这种方法，更加高效。大家会不会跟困惑这是为啥呢，我在这位大家简单地介绍下：</p><blockquote><p>首先我们知道，与运算的话必须是全部为 1 则为 1，如果要达到这样的效果的话，这个数值必须是 2 的 n 次方-1，肯定是所有 bit 为都为 1，这也就是为什么 map 要求数组容量必须是 2 的幂次方了。<br>接下来我们拿到 1111 这样的数值之后和我们的 hash 进行运算<br>11111000110011  &amp;  1111   这样运算之后得到的是 3<br>111111111111111  &amp;  1111 这样运算之后得到的是 15   永远也不会超过 15，大家这下应该知道这个原&gt;   理了吧</p></blockquote><ol><li>再接着判断如果是红黑树的话，则进行红黑树的相关操作</li><li>最后再判断如果是链表的话，则进行遍历迁移</li><li>这里一个主要的操作是 给索引相同的元素进行均分</li><li>将元素的 hash 和老的数组长度进行与操作，如果为，说明他的高位为 1，与新的数组长度进行与之后，还是原来的结果，如果不为 0，则可以直接将索引下标加上旧的数组长度，然后将节点引到新的数组对应的索引下面，这里大家有可能很懵，说这么多到底是什么意思呢，我以画图的形式和大家说下吧<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614522069129-e1d4fa11-3b1b-4a1e-afa0-54946050b2d6.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&originHeight=331&originWidth=1233&size=0&status=done&style=none&width=1233"></li></ol><p>我们看到上面会有两个 table，分别是扩容前的数组和扩容后的数组 5. oldTab 数组上的第七个索引上，元素的 hash 分别为 7 和 15，7 &amp;  （8-1）和 15 &amp; (8-1) 都得到的是<br>7，所以存放到了 7 上面， 6. 现在进行扩容，数组长度扩大为 16，这时候如果直接拿两个 hash 值和新的数组长度进行与运算的话，会得到 7 和 15 两个位置，这样链表就会被这两个位置均分掉 7. 但是我们看代码，jdk 并没有这么做，他先判断 hash 和原先的数组长度进行与操作，之前一直是和数组长度减 1 做与操作，如果结果为 0，说明他在新的数组上面索引的位置还是和当前一样，则直接把数据放到新数组上，如果不为 0 ，则只需要把当前索引位置加上旧的数组长度即可，因为数组扩容长旧数组两倍的，</p><p>讲了这么多，数组初始化这块讲完了<br>我们再回到前面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第一个判断处理完之后，我们继续往下看，</p><ol><li>p = tab[i = (n - 1) &amp; hash]) == null   判断如果数组所在的索引位置上的数据如果为空，则直接 new 一个新的 Node 直接放在元素上即可</li><li>如果不为空，则继续往下走</li><li>如果当前节点不为空，并且它的 key 值和我们传入的 key 是相等的，则直接取出这个节点，直接在这个节点上进行操作，后面再说</li><li>如果节点是红黑树节点，则进行红黑树相关的操作</li><li>如果上面条件都不满足的，则说明是一个链表结构，</li><li>遍历链表里面的元素</li><li>如果在链表里面找到了 key 值相同的节点，则直接取出这个节点，不再遍历</li><li>如果已经遍历到链表的最后一个节点都还没有拿到的话，则需要创建新的节点</li><li>这里有两种情况，通过 binCount 进行判断，这个变量用来干嘛的呢，我们会看到我们每次进行链表节点的时候都会把这个进行自增，其实也就是记录这个链表的长度</li><li>如果比较发现 链表的长度已经大于 map 中定义的 TREEIFY_THRESHOLD - 1 的话，也就是 7，就会将链表转换为红黑树，将数据存到红黑树中，这里为什么要减掉 1 呢，其实这块也是面试官必问的，也就是我刚开始提到的一个面试题：什么时候链表会转换成红黑树？map 里面定义的是 8，这里减了 1.是因为在我们进行遍历链表之前，我们已经取出来了数组上面的第一个链表元素了，后面的遍历是基于这个元素的 next 进行遍历的，所以这里就需要将 TREEIFY_THRESHOLD -1 作为转换条件判断。</li><li>最后我们看下这段代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>这个 e 也就是我们上面取出来的元素，如果判断不为空的话，则说明 map 中已经存在了这个元素，则只需要给他赋上新的值就好了，然后将旧值返回回去，<br>最后将数组长度加一，如果是更新操作，则不会走到这一步，加一之后如果发现当前的数组中元素的长度如果大于阈值则进行扩容操作。</p><p><strong>到这里终于把 map 中最重要的 put 操作讲完了，get 和 remove 操作大家可以按照这个思路自己去看下咯，刚开始的面试题也在文章里都有讲解到，还有一个多线程情况下，map 会出现什么问题，这个后续再说了，本文篇幅有点长。。。，文中有讲的不准确的地方，希望各位大佬指正</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;促使自己开始研究源码的原因主要有两个，第一个是在面试高级工程师的时候，源码这块是必问的，第二个原因是现在框架是越来</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>趣味编程故事｜java进程占用cpu过高怎么办，别急我来帮你</title>
    <link href="https://yangletec.github.io/post/4ac29acd.html"/>
    <id>https://yangletec.github.io/post/4ac29acd.html</id>
    <published>2021-02-27T09:43:33.000Z</published>
    <updated>2021-02-28T14:38:11.899Z</updated>
    
    <content type="html"><![CDATA[<hr><p>tags: [elk, springboot]<br>categories: 分布式专题</p><hr><hr><p>关注公众号“AI 码师”领取 2021 最新面试资料一份</p><h2 id="【主演】"><a href="#【主演】" class="headerlink" title="【主演】"></a>【主演】</h2><p>运维小哥：小李</p><p>测试小姐姐：小红</p><p>开发人员：本色出演</p><h2 id="【剧情】"><a href="#【剧情】" class="headerlink" title="【剧情】"></a>【剧情】</h2><p>在一个阳光明媚的清晨，原本还在睡梦中的我，被小李（运维小哥）的电话给惊醒了。<br>小李：线上告警出来一个问题，赶快看一下！<br>我：啥问题啊？<br>小李：xx 服务器 现在 cpu 已经 100%了，我刚才查了下是 java 进程占用的<br>我：好的，我来看下</p><p>我赶紧打开我的电脑，连接上了 xx 服务器，使用 top 命令查了下，确实是 java 进程占用 cpu 最高，我大脑飞速旋转想到:这几天也没有对程序做什么大改动啊，怎么会出现这个问题呢；</p><p>于是我把本地代码切换到 master 分支，在本地跑了下发布到线上的代码，观察了一会，也没看见 cpu 占用很高啊，我就很纳闷了，然后又上服务器看了下，java 进程占用 cpu 还是比较高的，这是怎么回事呢？难道要拿出我的杀手锏？</p><p>接下来场面就比较血腥了，前方高能预警，系好安全带</p><h2 id="【高能预警】"><a href="#【高能预警】" class="headerlink" title="【高能预警】"></a>【高能预警】</h2><p>我拿出了杀手锏，江湖上失传已久的九阴真经（其实就是平时的笔记哈哈），在上面找了一些命令，然后就是接下来的场景了：</p><p>【步骤一】找到最耗 cpu 的进程</p><p>top<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614419045130-6b142a76-4962-4434-8111-f269e0fd1ac2.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=1134&size=0&status=done&style=none&width=1134"></p><p>得到最占用 CPU 的进程为：39890</p><p>【步骤二】找到 39890 进程中最消耗 cpu 的线程</p><p>top -d 1 -Hp 39890</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614419045069-524634bf-ca5f-41c4-9d0b-92dba0e634d0.png#align=left&display=inline&height=338&margin=%5Bobject%20Object%5D&originHeight=338&originWidth=1136&size=0&status=done&style=none&width=1136"></p><p>得到最耗 CPU 的进程为 39900</p><p>【步骤二】将 PID 转换为十六进制</p><p>我们拿到了进程 PID 为：39900<br>我们需要将它转为十六进制，才能进行后续指令操作<br>printf “%x\n” 39900<br>得到结果：9bdc<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614419045070-0e7c7eff-c3dd-495e-bd51-0fbb6967a404.png#align=left&display=inline&height=82&margin=%5Bobject%20Object%5D&originHeight=82&originWidth=542&size=0&status=done&style=none&width=542"></p><p>【步骤三】打印当前线程的栈信息，看看它到底在干嘛</p><p>jstack 39890 | grep ‘9bdc’ -C5<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614419045176-b3063503-78e6-4697-83bd-abfe95ca31dd.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&originHeight=356&originWidth=1320&size=0&status=done&style=none&width=1320"></p><p>现在已经找到了线程的栈信息，我看到了我自己写的代码，我用红框标记出来了</p><p>【步骤四】带着疑问去找代码</p><p>我们根据栈信息，直接在我们项目上定位到了那段代码<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614419045079-ba7a782e-3ef6-492f-89e2-bdd1a6d0430f.png#align=left&display=inline&height=382&margin=%5Bobject%20Object%5D&originHeight=382&originWidth=918&size=0&status=done&style=none&width=918"></p><p>我发现，这里有一个死循环，我擦，忘记加休眠时间了，导致一直在死循环跑呢，终于找到问题根源了，加上了休眠时间，然后本地测试了下没问题；</p><p>关键这是线上的问题，得要赶紧上线啊，但是也得测试呢，我不得不拨通了小红（测试小姐姐）的电话，嘀。嘀。嘀。，我心里也在滴滴滴，这么早打电话给她让她测试，免不了被训，我已经做好了心里准备了，咦，通了：</p><p>小红：干啥？（测试小姐姐总是这么彪悍）</p><p>我：有有有一个小小的线上问题(说话已经开始紧张了，生怕她开骂，哈哈)，我已经改好了，需要你测试下，然后抓紧上线。</p><p>小红：今天不是周末么，还要测试，让不让人睡觉了啊？</p><p>我：我我。。。，小姐姐，你长得这么可爱，美丽，端庄，温柔，贤惠，就帮忙测试下么，不然我这个月绩效又要被扣了…</p><p>小红：看你这么诚实，这次就勉强帮你测试下吧，但是下次不要在周末给我发提测了。</p><p>我：好的呢，下…(对方已经挂断了电话…)</p><p>哈哈，不管咋样，现在已经没我的事了，我合上电脑，又进入了梦乡…</p><h2 id="全剧终"><a href="#全剧终" class="headerlink" title="全剧终"></a>全剧终</h2><p>经历了一次线上 bug 排查，让我胆战心惊，不过这次也给我增加了不少经验，毕竟重拾了 九阴正经，让我内功又增强了；<br>后期会发布更多在实战方面的工作经验，与大家分享，希望大家能够喜欢，现在我需要你们的一键三连，哈哈，下期见。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;tags: [elk, springboot]&lt;br&gt;categories: 分布式专题&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;关注公众号“AI 码师”领取 2021 最新面试资料一份&lt;/p&gt;
&lt;h2 id=&quot;【主演】&quot;&gt;&lt;a href=&quot;#【主演】&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>5年老java开发，我看过哪些书，看过哪些视频，刷过哪些面试题，都在这里了</title>
    <link href="https://yangletec.github.io/post/2f39c1bc.html"/>
    <id>https://yangletec.github.io/post/2f39c1bc.html</id>
    <published>2021-02-27T09:40:32.000Z</published>
    <updated>2021-02-28T14:38:11.919Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tags: [面试,资料]</span><br><span class="line">categories: 面试</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><hr><p>本篇文章没有任何水文，全是干货</p><p>作为 5 年开发工程师，拥有 5 年一线大厂的开发经验； 在大学就开始自学 java，在这期间有迷茫过，也想放弃过，但是最后都坚持了下来；</p><p>现在我把我自己一路走来珍藏的资料和学习方法都分享给大家，谨献给有需要的和准备涉及此行业的同学。</p><blockquote><p>关注公众号“AI 码师”,公众号内回复“5 年”，可免费领取资料</p></blockquote><p>电子书籍大概 2.5g；视频教程大概 7.3g；</p><h1 id="电子书籍"><a href="#电子书籍" class="headerlink" title="电子书籍"></a>电子书籍</h1><h2 id="JAVA-入门必备"><a href="#JAVA-入门必备" class="headerlink" title="JAVA 入门必备"></a>JAVA 入门必备</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614418933484-96dc6c72-d81c-42a4-bd44-251b9e2b873c.png#align=left&display=inline&height=236&margin=%5Bobject%20Object%5D&originHeight=236&originWidth=620&size=0&status=done&style=none&width=620"></p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614418933392-c4473b13-eced-44b4-ac7b-161330ca0dcf.png#align=left&display=inline&height=116&margin=%5Bobject%20Object%5D&originHeight=116&originWidth=586&size=0&status=done&style=none&width=586"></p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614418933441-70c9ea58-b879-4a64-8997-0b8bcdcbf07e.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&originHeight=356&originWidth=642&size=0&status=done&style=none&width=642"></p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614418933473-a4024fe9-315f-4ebc-a8c9-f92eb0ecc5cc.png#align=left&display=inline&height=396&margin=%5Bobject%20Object%5D&originHeight=396&originWidth=1006&size=0&status=done&style=none&width=1006"></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614418933402-c0aa8cba-7a8d-47c8-9c5e-a5cf1cb9aed1.png#align=left&display=inline&height=160&margin=%5Bobject%20Object%5D&originHeight=160&originWidth=686&size=0&status=done&style=none&width=686"></p><h2 id="阿里技术图册"><a href="#阿里技术图册" class="headerlink" title="阿里技术图册"></a>阿里技术图册</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614418933431-86a736a4-2731-480f-b05e-8c7e69c7b922.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&originHeight=118&originWidth=590&size=0&status=done&style=none&width=590"></p><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614418933404-c45cda8e-b95c-4104-973b-3024cc12554e.png#align=left&display=inline&height=160&margin=%5Bobject%20Object%5D&originHeight=160&originWidth=806&size=0&status=done&style=none&width=806"></p><h2 id="2021-最新面试资料（四套）"><a href="#2021-最新面试资料（四套）" class="headerlink" title="2021 最新面试资料（四套）"></a>2021 最新面试资料（四套）</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614418933458-b8ec1eda-1e1c-4332-82b4-04951ad130b9.png#align=left&display=inline&height=1668&margin=%5Bobject%20Object%5D&originHeight=1668&originWidth=820&size=0&status=done&style=none&width=820"></p><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h2 id="架构师教程"><a href="#架构师教程" class="headerlink" title="架构师教程"></a>架构师教程</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614418933506-be203f49-1c17-41d0-8ffc-d8a6876e2e90.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&originHeight=708&originWidth=1008&size=0&status=done&style=none&width=1008"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>趣味编程｜手写一个集成多数据源mongodb的 starter</title>
    <link href="https://yangletec.github.io/post/3475e752.html"/>
    <id>https://yangletec.github.io/post/3475e752.html</id>
    <published>2021-02-27T08:50:31.000Z</published>
    <updated>2021-02-28T14:38:11.987Z</updated>
    
    <content type="html"><![CDATA[<p>关注公众号“AI 码师”领取 2021 最新面试资料一份，公众号内回复“源码”，获取本项目源码</p><h2 id="【前言】"><a href="#【前言】" class="headerlink" title="【前言】"></a>【前言】</h2><p>主演：老王(技术总监)，小码（本猿）</p><p>老王：小码啊，我们项目中需要使用到 mongodb，你集成下吧，完成了和我说下。</p><p>小码：好的，一会就给你弄好。</p><p>小码三下五除二的给集成好了，然后给老王汇报了。</p><p>小码：王哥，我已经把 mongodb 集成好了。</p><p>老王：好的，现在由于我们项目中会用到很多 mongo 数据库，你现在集成的 mongo 支持多数据源动态切换么？</p><p>小码：这个，这个，啥叫多数据源动态切换啊？</p><p>老王：就是在运行过程中，能够根据需要动态去连接哪个数据库，咱们项目需要支持多个特性，如果你对这个不太清楚的话，我给你一个思路，你可以考虑使用切面来实现，具体怎么弄，你自己研究下.</p><p>小码：好的，王哥。</p><p>小码想了很久，各种百度，终于找到了解决方案，花了一上午的时间，终于弄完了，又去给老王汇报了。</p><p>小码：王哥，现在项目中的 mongo 已经实现了多数据源了（哈哈，心里很自豪）。</p><p>老王：小伙子，很快嘛，不过现在又来一个任务，你需要把你集成的这个功能封装成一个 starter，另外一个项目也需要使用这个功能，你抽时间封装下吧。</p><p>小码：好的，王哥，保证完成任务</p><p>小码下去之后，就开始研究怎么去封装成一个 starter，下班之前弄好了，不过这次他没去找老王了，准备第二天再去，不然又得加班，哈哈！！！</p><h2 id="【正文】"><a href="#【正文】" class="headerlink" title="【正文】"></a>【正文】</h2><p>前面水了那么多，主要是给大家设置一种场景，让同志们知道为啥要去做这么一个功能，现在就直接进入正题了：</p><h3 id="【springboot-集成-mongodb】"><a href="#【springboot-集成-mongodb】" class="headerlink" title="【springboot 集成 mongodb】"></a>【springboot 集成 mongodb】</h3><ul><li>引入 mongodb 依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>配置 mongodb 连接信息，在 application.yml 中配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 设置了用户名和密码的连接</span><br><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    mongodb:</span><br><span class="line">      uri: mongodb:&#x2F;&#x2F;用户名:密码@IP:PORT&#x2F;数据库?authSource&#x3D;$&#123;auth_db:用户认证数据库&#125;</span><br><span class="line"># 没有设置用户名和密码的连接配置</span><br><span class="line">spring:</span><br><span class="line">    data:</span><br><span class="line">        mongodb:</span><br><span class="line">            uri: mongodb:&#x2F;&#x2F;IP:PORT&#x2F;数据库</span><br></pre></td></tr></table></figure><ul><li>写测试代码</li></ul><p>我们创建一个接口，然后在接口方法中去操作 monog 库:</p><p>接口中，直接引入 MongoTemplate，就可以直接操作 mongo 了，这里对 mongo 如何使用不做过多介绍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by AI码师 on 2019&#x2F;4&#x2F;19.</span><br><span class="line"> * 关注公众号【AI码师】领取2021最新面试资料一份（很全）</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RequestMapping(&quot;&#x2F;home&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class HomeController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MongoTemplate mongoTemplate;</span><br><span class="line">    @PostMapping</span><br><span class="line">    public String addData(@RequestParam(value &#x3D; &quot;name&quot;) String name,@RequestParam(value &#x3D; &quot;addr&quot;) String addr,@RequestParam(value &#x3D; &quot;email&quot;) String email)&#123;</span><br><span class="line">        Student student &#x3D; new Student();</span><br><span class="line">        student.setAddr(addr);</span><br><span class="line">        student.setName(name);</span><br><span class="line">        student.setEmail(email);</span><br><span class="line">        mongoTemplate.insert(student);</span><br><span class="line">        return &quot;添加成功&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求接口：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614415836996-a6a5f7b5-0a7b-4255-8ccc-36612ba56da2.png#align=left&display=inline&height=530&margin=%5Bobject%20Object%5D&originHeight=530&originWidth=2794&size=0&status=done&style=none&width=2794"></p><p>响应数据：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614415837055-ae8ec38c-c18d-403d-ac65-dc9b7f60b857.png#align=left&display=inline&height=666&margin=%5Bobject%20Object%5D&originHeight=666&originWidth=2622&size=0&status=done&style=none&width=2622"></p><p>响应添加成功，我们看下数据库，是否添加上去了：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614415837001-ff379413-9118-4214-90b6-658c7d14a0f8.png#align=left&display=inline&height=272&margin=%5Bobject%20Object%5D&originHeight=272&originWidth=2530&size=0&status=done&style=none&width=2530"></p><p>数据已经添加上去了，说明已经集成成功了，但这还是第一步，我们需要做的是支持多数据源，接下来我们一起来完成逼格更高的多数据源 mongo 吧。</p><h3 id="【实现多数据源】"><a href="#【实现多数据源】" class="headerlink" title="【实现多数据源】"></a>【实现多数据源】</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>先介绍下实现多数据源动态切换的思路：</p><p>首先通过 AOP 技术，在调用方法前后动态替换 mongo 数据源，这个主要是替换 mongo 中 mongodbfactory(SimpleMongoClientDatabaseFactory)值,每个 factory 都维护自己需要连接的库，如果在操作之前，替换该参数为自己需要操作的数据库 factory，操作结束又切换成原来的，不就可以实现动态切换数据源了么。</p><p>说完了思路，我们直接上代码吧</p><h4 id="垒代码"><a href="#垒代码" class="headerlink" title="垒代码"></a>垒代码</h4><ul><li>添加 aop 依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入AOP依赖--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>修改数据库连接配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置了用户名和密码的连接</span><br><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    mongodb:</span><br><span class="line">      uri: mongodb:&#x2F;&#x2F;用户名:密码@IP:PORT&#x2F;#?authSource&#x3D;$&#123;auth_db:用户认证数据库&#125;</span><br><span class="line"># 没有设置用户名和密码的连接配置</span><br><span class="line">spring:</span><br><span class="line">    data:</span><br><span class="line">        mongodb:</span><br><span class="line">            uri: mongodb:&#x2F;&#x2F;IP:PORT&#x2F;#</span><br><span class="line"></span><br><span class="line">与上述配置，做了小小的改动，将操作的数据库名称替换成了#，用来做后续备用</span><br></pre></td></tr></table></figure><ul><li>创建切面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package com.aimashi.dynamicmongo.config;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.data.mongodb.core.MongoDatabaseFactorySupport;</span><br><span class="line">import org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line">import org.springframework.data.mongodb.core.SimpleMongoClientDatabaseFactory;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by AI码师 on 2019&#x2F;4&#x2F;19.</span><br><span class="line"> * 关注公众号【AI码师】领取2021最新面试资料一份（很全）</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MongoSwitch &#123;</span><br><span class="line">  private final Logger logger &#x3D; LoggerFactory.getLogger(MongoSwitch.class);</span><br><span class="line"></span><br><span class="line">  @Autowired private MongoDatabaseFactorySupport mongoDbFactory;</span><br><span class="line">  private final Map&lt;String, MongoDatabaseFactorySupport&gt; templateMuliteMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  &#x2F;&#x2F; 获取配置文件的副本集连接</span><br><span class="line">  @Value(&quot;$&#123;spring.data.mongodb.uri&#125;&quot;)</span><br><span class="line">  private String uri;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;@Pointcut(&quot;@annotation(com.pig4cloud.pig.common.log.annotation.MongoLog)&quot;)</span><br><span class="line">  @Pointcut(&quot;execution(public * com.aimashi.dynamicmongo.config.MongotemplteService.*(..))&quot;)</span><br><span class="line">  public void routeMongoDB() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Around(&quot;routeMongoDB()&quot;)</span><br><span class="line">  public Object routeMongoDB(ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line">    Object result &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 获取需要访问的项目数据库</span><br><span class="line">    String dbName &#x3D; (String) joinPoint.getArgs()[0];</span><br><span class="line">    Object o &#x3D; joinPoint.getTarget();</span><br><span class="line">    Field[] fields &#x3D; o.getClass().getDeclaredFields();</span><br><span class="line">    MultiMongoTemplate mongoTemplate &#x3D; null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      for (Field field : fields) &#123;</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        Class fieldclass &#x3D; field.getType();</span><br><span class="line">        &#x2F;&#x2F; 找到Template的变量</span><br><span class="line">        if (fieldclass &#x3D;&#x3D; MongoTemplate.class || fieldclass &#x3D;&#x3D; MultiMongoTemplate.class) &#123;</span><br><span class="line">          &#x2F;&#x2F; 查找项目对应的MongFactory</span><br><span class="line">          SimpleMongoClientDatabaseFactory simpleMongoClientDbFactory &#x3D; null;</span><br><span class="line">          &#x2F;&#x2F; 实例化</span><br><span class="line">          if (templateMuliteMap.get(dbName) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 替换数据源</span><br><span class="line">            simpleMongoClientDbFactory &#x3D;</span><br><span class="line">                new SimpleMongoClientDatabaseFactory(this.uri.replace(&quot;#&quot;, dbName));</span><br><span class="line">            templateMuliteMap.put(dbName, simpleMongoClientDbFactory);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            simpleMongoClientDbFactory &#x3D;</span><br><span class="line">                (SimpleMongoClientDatabaseFactory) templateMuliteMap.get(dbName);</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 如果第一次，赋值成自定义的MongoTemplate子类</span><br><span class="line">          if (fieldclass &#x3D;&#x3D; MongoTemplate.class) &#123;</span><br><span class="line">            mongoTemplate &#x3D; new MultiMongoTemplate(simpleMongoClientDbFactory);</span><br><span class="line">          &#125; else if (fieldclass &#x3D;&#x3D; MultiMongoTemplate.class) &#123;</span><br><span class="line">            Object fieldObject &#x3D; field.get(o);</span><br><span class="line">            mongoTemplate &#x3D; (MultiMongoTemplate) fieldObject;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 设置MongoFactory</span><br><span class="line">          mongoTemplate.setMongoDbFactory(simpleMongoClientDbFactory);</span><br><span class="line">          &#x2F;&#x2F; 重新赋值</span><br><span class="line">          field.set(o, mongoTemplate);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">        result &#x3D; joinPoint.proceed();</span><br><span class="line">        &#x2F;&#x2F; 清理ThreadLocal的变量</span><br><span class="line">        mongoTemplate.removeMongoDbFactory();</span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.error(&quot;&quot;, t);</span><br><span class="line">        mongoTemplate.removeMongoDbFactory();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      logger.error(&quot;&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建相关配置类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.aimashi.dynamicmongo.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by AI码师 on 2019&#x2F;4&#x2F;19.</span><br><span class="line"> * 关注公众号【AI码师】领取2021最新面试资料一份（很全）</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Service</span><br><span class="line">public class MongotemplteService &#123;</span><br><span class="line">  private MongoTemplate mongoTemplate;</span><br><span class="line">  public &lt;T&gt; T save(String dbName, T var1) &#123;</span><br><span class="line">    return mongoTemplate.save(var1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.aimashi.dynamicmongo.config;</span><br><span class="line"></span><br><span class="line">import com.mongodb.client.MongoDatabase;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.data.mongodb.core.MongoDatabaseFactorySupport;</span><br><span class="line">import org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line"></span><br><span class="line">public class MultiMongoTemplate extends MongoTemplate &#123;</span><br><span class="line">    private Logger logger&#x3D; LoggerFactory.getLogger(MultiMongoTemplate.class);</span><br><span class="line">&#x2F;&#x2F;用来缓存当前MongoDbFactory</span><br><span class="line">    private static ThreadLocal&lt;MongoDatabaseFactorySupport&gt; mongoDbFactoryThreadLocal;</span><br><span class="line">    public MultiMongoTemplate(MongoDatabaseFactorySupport mongoDbFactory)&#123;</span><br><span class="line">        super(mongoDbFactory);</span><br><span class="line">        if(mongoDbFactoryThreadLocal&#x3D;&#x3D;null) &#123;</span><br><span class="line">            mongoDbFactoryThreadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMongoDbFactory(MongoDatabaseFactorySupport factory)&#123;</span><br><span class="line">        mongoDbFactoryThreadLocal.set(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeMongoDbFactory()&#123;</span><br><span class="line">        mongoDbFactoryThreadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MongoDatabase getDb() &#123;</span><br><span class="line">        return mongoDbFactoryThreadLocal.get().getMongoDatabase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加测试接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by AI码师 on 2019&#x2F;4&#x2F;19.</span><br><span class="line"> * 关注公众号【AI码师】领取2021最新面试资料一份（很全）</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; dbName 为数据库名称</span><br><span class="line">   @PutMapping</span><br><span class="line">    public String addDataByDynamic(@RequestParam(value &#x3D; &quot;dbName&quot;) String dbName,@RequestParam(value &#x3D; &quot;name&quot;) String name,@RequestParam(value &#x3D; &quot;addr&quot;) String addr,@RequestParam(value &#x3D; &quot;email&quot;) String email)&#123;</span><br><span class="line">        Student student &#x3D; new Student();</span><br><span class="line">        student.setAddr(addr);</span><br><span class="line">        student.setName(name);</span><br><span class="line">        student.setEmail(email);</span><br><span class="line">        mongotemplteService.insert(dbName,student);</span><br><span class="line">        return &quot;添加成功&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>请求接口：数据库名参数传了 ams1</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614415837060-328c0774-013b-4ffb-a1c3-96518ae813f3.png#align=left&display=inline&height=710&margin=%5Bobject%20Object%5D&originHeight=710&originWidth=2646&size=0&status=done&style=none&width=2646"></p><p>请求响应：响应成功<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614415837004-9aff068a-ac7a-495f-8348-87bcd32259c2.png#align=left&display=inline&height=682&margin=%5Bobject%20Object%5D&originHeight=682&originWidth=2858&size=0&status=done&style=none&width=2858"></p><p>我们看下数据库，发现在数据库 ams1 下面已经有了此数据：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614415837039-f3166664-e6c7-46ab-b603-0891c4ed67e7.png#align=left&display=inline&height=266&margin=%5Bobject%20Object%5D&originHeight=266&originWidth=2472&size=0&status=done&style=none&width=2472"></p><p>我们将数据库名参数修改为：ams2，进行请求</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614415837062-4605d6cd-2ba2-41ce-982c-0d13470b03f1.png#align=left&display=inline&height=694&margin=%5Bobject%20Object%5D&originHeight=694&originWidth=2794&size=0&status=done&style=none&width=2794"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614415837028-3c02ca29-02aa-4a1a-9a26-010d57ae96a4.png#align=left&display=inline&height=316&margin=%5Bobject%20Object%5D&originHeight=316&originWidth=2506&size=0&status=done&style=none&width=2506"></p><p>发现数据源已经切换成功了。</p><p>到这里，大家有没有发现自己很牛逼了啊，不过本篇文章还没算完，现在虽然已经实现了动态切换数据源的功能，但是还只能在自己项目上用，别的项目需要使用，只能直接复制过去，我们接下来需要做一个更牛逼的事情：手写一个 starter 来封装这个功能，别人只需要引入依赖，即可开箱即用：</p><h3 id="【整合到-starter-里面】"><a href="#【整合到-starter-里面】" class="headerlink" title="【整合到 starter 里面】"></a>【整合到 starter 里面】</h3><ul><li>创建一个 maven 项目：dynamicmongo-starter</li></ul><p>将如下文件拷贝到新项目中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12552073/1614415837061-4c6d37d5-05f5-4d4f-ac74-b541de6135ce.png#align=left&display=inline&height=126&margin=%5Bobject%20Object%5D&originHeight=126&originWidth=480&size=0&status=done&style=none&width=480"></p><ul><li>创建自动装配文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.aimashi.dynamicmongo.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by AI码师 on 2019&#x2F;4&#x2F;19.</span><br><span class="line"> * 关注公众号【AI码师】领取2021最新面试资料一份（很全）</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration(proxyBeanMethods &#x3D; false)</span><br><span class="line">public class MongodbAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public MongoSwitch mongoSwitch() &#123;</span><br><span class="line">return new MongoSwitch();</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">public MongotemplteService mongotemplteService() &#123;</span><br><span class="line">return new MongotemplteService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建 resources/META_INF/spring.factories 文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">    com.aimashi.dynamicmongo.config.MongodbAutoConfiguration</span><br></pre></td></tr></table></figure><p>到这里 starter 已经编写完成，是不是很简单。。</p><h3 id="【使用-starter】"><a href="#【使用-starter】" class="headerlink" title="【使用 starter】"></a>【使用 starter】</h3><p>starter 已经编写好，我们只需要在项目中引入该依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.aimashi&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dynamicmongo-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>然后在需要操作 mongod 方法的地方，引入：MongotemplteService 即可；</p><p>注意 MongotemplteService 里面的方法大家按需扩充，目前只写了一个，大家使用的时候，只需要把 mongoTemplate 里面的方法名写到 MongotemplteService 中，然后再去调用 mongoTemplate 里面对应方法即可。</p><h2 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h2><p>很少写这么长的实践类文章，现在已经十一点半了，该休息了，后面会有更多文章和大家一起分享，希望大家能有所收获，晚安！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关注公众号“AI 码师”领取 2021 最新面试资料一份，公众号内回复“源码”，获取本项目源码&lt;/p&gt;
&lt;h2 id=&quot;【前言】&quot;&gt;&lt;a href=&quot;#【前言】&quot; class=&quot;headerlink&quot; title=&quot;【前言】&quot;&gt;&lt;/a&gt;【前言】&lt;/h2&gt;&lt;p&gt;主演：老王(技</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工作经验｜lambada处理集合的常用10种实战骚操作，我都记录下来了</title>
    <link href="https://yangletec.github.io/post/465c9d.html"/>
    <id>https://yangletec.github.io/post/465c9d.html</id>
    <published>2021-02-27T06:54:08.000Z</published>
    <updated>2021-02-28T14:38:12.015Z</updated>
    
    <content type="html"><![CDATA[<p>关注公众号“AI 码师”领取 2021 最新面试资料一份，公众号内回复“源码”，获取本项目源码</p><p>最近在项目上面经常使用 lambada 表达式，但是总是记不住，一直都在百度，写完之后就忘记了，感觉很费时间；这次就花点时间，把一些常用的 lambada 处理集合的实例都保存了下来(去重，分组，求和，list 转 map 等等)，以后就不用到处找了，刚好也可以给同学们分享下；另外也把一些关于使用 lambada 时遇到的坑也给大家一起分享下，所有代码拿来即用！！！本文档持续更新…</p><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>商品实体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class GoodInfo &#123;</span><br><span class="line">    private String mallSource;</span><br><span class="line">    private String skuNo;</span><br><span class="line">    private int price;</span><br><span class="line">    private int monthCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>集合排序在项目中用的频率还蛮高，这里以按照销量排序为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 按照销量正序 从小到大排序</span><br><span class="line"> goodInfos.sort(Comparator.comparing(GoodInfo::getMonthCount));</span><br><span class="line"> &#x2F;&#x2F; 按照销量倒序 从大到小排序</span><br><span class="line"> goodInfos.sort(Comparator.comparing(GoodInfo::getMonthCount).reversed());</span><br></pre></td></tr></table></figure><h3 id="取最大值-取最小值-求和"><a href="#取最大值-取最小值-求和" class="headerlink" title="取最大值/取最小值/求和"></a>取最大值/取最小值/求和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取最大销量  注意如果求最大值是在filter之后使用例如，goodInfos.stream().filter().max一定要判断filter后集合数量是否不为空，否则使用max的get方法会报错</span><br><span class="line">GoodInfo hotGoodInfo &#x3D; goodInfos.stream().max(Comparator.comparing(GoodInfo::getMonthCount)).get();</span><br><span class="line">&#x2F;&#x2F; 求最低价格商品</span><br><span class="line">GoodInfo lowPriceGoodInfo &#x3D; goodInfos.stream().min(Comparator.comparing(GoodInfo::getMonthCount)).get();</span><br><span class="line">&#x2F;&#x2F; 计算商品总价格</span><br><span class="line">int sum &#x3D; goodInfos.stream().mapToInt(person -&gt; person.getPrice()).sum();</span><br><span class="line">&#x2F;&#x2F; 求平均价格</span><br><span class="line">double avg &#x3D; goodInfos.stream().mapToInt(person -&gt; person.getPrice()).average().getAsDouble();</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));</span><br><span class="line"> goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 遍历输出所有商品id</span><br><span class="line"> goodInfos.forEach(</span><br><span class="line">     goodInfo -&gt; &#123;</span><br><span class="line">       System.out.println(goodInfo.getSkuNo());</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><h3 id="实体集合-转-单个属性的集合"><a href="#实体集合-转-单个属性的集合" class="headerlink" title="实体集合 转 单个属性的集合"></a>实体集合 转 单个属性的集合</h3><p>往往在我们项目中会有这样的需求：我需要提取集合中某一个属性，然后组装成集合，通常做法是先创建一个字符串集合，然后遍历原始集合，取出数据，放到字符串集合中，虽然也能实现功能，但是不免太过于繁琐，现在使用一行 lambada 表达式即可搞定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将list转为某个属性map 这里是把所有skuno全部取出来 作为集合</span><br><span class="line">List&lt;String&gt; skuNos &#x3D; goodInfos.stream().map(goodInfo -&gt; goodInfo.getSkuNo()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="实体集合-转-map-返回"><a href="#实体集合-转-map-返回" class="headerlink" title="实体集合 转 map 返回"></a>实体集合 转 map 返回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将list转为map，key 为商品id</span><br><span class="line">Map&lt;String, GoodInfo&gt; map &#x3D; goodInfos.stream().collect(Collectors.toMap(GoodInfo::getSkuNo, goodInfo -&gt; goodInfo));</span><br></pre></td></tr></table></figure><h3 id="实体集合按照某个属性分组"><a href="#实体集合按照某个属性分组" class="headerlink" title="实体集合按照某个属性分组"></a>实体集合按照某个属性分组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 按照商品来源分组</span><br><span class="line">Map&lt;String, List&lt;GoodInfo&gt;&gt; map &#x3D; goodInfos.stream().collect(Collectors.groupingBy(GoodInfo::getMallSource));</span><br></pre></td></tr></table></figure><h3 id="过滤数据（记得接收）"><a href="#过滤数据（记得接收）" class="headerlink" title="过滤数据（记得接收）"></a>过滤数据（记得接收）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 过滤商品价格大于300的</span><br><span class="line">&#x2F;&#x2F; todo 过滤后一定要使用集合接收，否则等于没有过滤</span><br><span class="line"></span><br><span class="line">List&lt;GoodInfo&gt; collect &#x3D;</span><br><span class="line">    goodInfos.stream()</span><br><span class="line">        .filter(goodInfo -&gt; goodInfo.getPrice() &gt; 300)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">collect.forEach(</span><br><span class="line">    goodInfo -&gt; &#123;</span><br><span class="line">      System.out.println(goodInfo.getPrice());</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="去重-两种方法可选"><a href="#去重-两种方法可选" class="headerlink" title="去重(两种方法可选)"></a>去重(两种方法可选)</h3><h4 id="方法一-set-去重"><a href="#方法一-set-去重" class="headerlink" title="方法一 set 去重"></a>方法一 set 去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));</span><br><span class="line">goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用treeset 集合来实现去重，这里一定要使用集合接收，不然等于没有去重</span><br><span class="line">List&lt;GoodInfo&gt; goodInfos1 &#x3D;</span><br><span class="line">    goodInfos.stream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.collectingAndThen(</span><br><span class="line">                Collectors.toCollection(</span><br><span class="line">                    () -&gt; new TreeSet&lt;&gt;(Comparator.comparing(o -&gt; o.getSkuNo()))),</span><br><span class="line">                ArrayList::new));</span><br></pre></td></tr></table></figure><h4 id="方法二-map-去重"><a href="#方法二-map-去重" class="headerlink" title="方法二 map 去重"></a>方法二 map 去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();</span><br><span class="line">    goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));</span><br><span class="line">    goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));</span><br><span class="line">    goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line">    goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));</span><br><span class="line">    goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));</span><br><span class="line">    goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));</span><br><span class="line">    goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用map去重</span><br><span class="line">    List&lt;GoodInfo&gt; goodInfos2 &#x3D;</span><br><span class="line">        goodInfos.stream()</span><br><span class="line">            .filter(distinctByKey(goodInfo -&gt; goodInfo.getSkuNo()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, ?&gt; keyExtractor) &#123;</span><br><span class="line">    Map&lt;Object, Boolean&gt; seen &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) &#x3D;&#x3D; null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><h3 id="坑一"><a href="#坑一" class="headerlink" title="坑一"></a>坑一</h3><ul><li>报错信息：<br>java.util.NoSuchElementException: No value present</li><li>解决方案：<br>一般出现这个错都是在 filter 操作后面使用了 max/min 等操作，然后调用了 get 方法，取不到数据，导致报错，所以建议检查 filter 操作后时候还有数据，有数据再进行后续操作：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    Optional&lt;User&gt; optional &#x3D; goodInfos.stream().max(userComparator);</span><br><span class="line">if(optional !&#x3D; null &amp;&amp; optional.isPresent()) &#123;</span><br><span class="line">    recentUserServer &#x3D; optional.get().getServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h3><ul><li>使用了 filter 为什么没起作用呢？</li></ul><p>调用 filter 之后，它是有返回值的，所以你需要使用新的集合去接收</p><p>。。。</p><p>后续慢慢填坑</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关注公众号“AI 码师”领取 2021 最新面试资料一份，公众号内回复“源码”，获取本项目源码&lt;/p&gt;
&lt;p&gt;最近在项目上面经常使用 lambada 表达式，但是总是记不住，一直都在百度，写完之后就忘记了，感觉很费时间；这次就花点时间，把一些常用的 lambada 处理集合</summary>
      
    
    
    
    
  </entry>
  
</feed>
