{"meta":{"title":"AI码师","subtitle":"授人以鱼不如授人以渔","description":"拥有五年一线大厂开发经验，擅长分布式、微服务、性能调优、源码分析、并发编程、面试经验分享等众多技能,关注公众号“AI码师”领取2021最新面试资料一份","author":"AI码师","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-02-28T14:18:05.069Z","updated":"2021-02-28T14:18:05.069Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-02-28T14:18:05.069Z","updated":"2021-02-28T14:18:05.069Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"自语 大家好，我是一枚会前端的后端开发工程师 👨🏻‍💻，目前主攻 Java 后端开发. 我希望用代码改变世界,我也在改变世界,自豪脸 😏 目前正走在成为一个厉害(Zhuang Bi)程序猿的路上. 前途很艰辛, 但是我会坚持! 生活不止有撸码和工作, 也有诗和远方. 在快乐中生活, 在快乐中工作, 爱家人, 爱自己 子曰：生而知之者，上也；学而知之者，次也；困而学之，又其次也；困而不学，民斯为下矣。人生得意须尽欢，莫使金樽空对月。少小须勤学，文章可立身。满朝朱紫贵，尽是读书人。 技能 语言：Java, JavaScript, HTML, CSS 数据库：MySQL, Redis, Oracle 开发框架：Spring, Spring Boot, Spring Cloud, MyBatis, Guice, Shiro, React, JQuery，Bootstrap 中间件：Kafka, Zookeeper 构建工具： Maven, Tomcat 环境： Mac, Ubuntu, Linux, Git, Intellij IDEA 学习 有道是学无止境，Java 后端开发的路很难走，但是既然走了这条路，那就得一直走下去。 Java 相关的技术栈很多，学起来很不容易，最近两年的行情也是优胜劣汰，希望自己能够快速成长起来 夯实基础，学习源码 今年想要学习一下 python 博客 期望：平时生活和工作一种记录, 希望之后回过头再来看自己的博客也会有所收获或感想 技术、电影与生活 对生活和学习的一个记录 希望自己越来越强大，越来越开心 免责声明 本站所有文章为了记录工作、学习中遇到的问题，可能由于本人技术有限，有些不正确的地方，仅供参考 本站文章引用或转载写明来源，感谢原作者的辛苦写作，如果有异议或侵权，及时联系我处理，谢谢！ 如他人引用本站中的文章或内容，请注明出处。但其文章或内容已不是本人原本的意思，请各位注意辨别！ 本站所有文章仅代表个人当时意见和想法 欢迎指出有问题的地方，我会尽快修正，谢谢！ 内容转载请保留署名以及原文连接，谢谢? 本网站所有作品采用 知识共享署名-相同方式共享 4.0 国际许可协议 进行许可。 关注我关注公众号“AI 码师”领取 2021 最新面试资料一份"},{"title":"书单","date":"2021-02-28T14:18:05.069Z","updated":"2021-02-28T14:18:05.069Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-28T14:18:05.069Z","updated":"2021-02-28T14:18:05.069Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-02-28T14:18:05.069Z","updated":"2021-02-28T14:18:05.069Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-02-28T14:18:05.069Z","updated":"2021-02-28T14:18:05.069Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-28T14:18:05.069Z","updated":"2021-02-28T14:18:05.069Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-02-28T14:18:05.069Z","updated":"2021-02-28T14:18:05.069Z","comments":true,"path":"2021/02/28/hello-world/","link":"","permalink":"http://example.com/2021/02/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"趣味编程故事｜java进程占用cpu过高怎么办，别急我来帮你","slug":"yuque/趣味编程故事｜java进程占用cpu过高怎么办，别急我来帮你","date":"2021-02-27T09:43:33.000Z","updated":"2021-02-28T14:18:34.345Z","comments":true,"path":"2021/02/27/yuque/趣味编程故事｜java进程占用cpu过高怎么办，别急我来帮你/","link":"","permalink":"http://example.com/2021/02/27/yuque/%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B%E6%95%85%E4%BA%8B%EF%BD%9Cjava%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8cpu%E8%BF%87%E9%AB%98%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%8C%E5%88%AB%E6%80%A5%E6%88%91%E6%9D%A5%E5%B8%AE%E4%BD%A0/","excerpt":"","text":"tags: [elk, springboot]categories: 分布式专题 关注公众号“AI 码师”领取 2021 最新面试资料一份 【主演】运维小哥：小李 测试小姐姐：小红 开发人员：本色出演 【剧情】在一个阳光明媚的清晨，原本还在睡梦中的我，被小李（运维小哥）的电话给惊醒了。小李：线上告警出来一个问题，赶快看一下！我：啥问题啊？小李：xx 服务器 现在 cpu 已经 100%了，我刚才查了下是 java 进程占用的我：好的，我来看下 我赶紧打开我的电脑，连接上了 xx 服务器，使用 top 命令查了下，确实是 java 进程占用 cpu 最高，我大脑飞速旋转想到:这几天也没有对程序做什么大改动啊，怎么会出现这个问题呢； 于是我把本地代码切换到 master 分支，在本地跑了下发布到线上的代码，观察了一会，也没看见 cpu 占用很高啊，我就很纳闷了，然后又上服务器看了下，java 进程占用 cpu 还是比较高的，这是怎么回事呢？难道要拿出我的杀手锏？ 接下来场面就比较血腥了，前方高能预警，系好安全带 【高能预警】我拿出了杀手锏，江湖上失传已久的九阴真经（其实就是平时的笔记哈哈），在上面找了一些命令，然后就是接下来的场景了： 【步骤一】找到最耗 cpu 的进程 top 得到最占用 CPU 的进程为：39890 【步骤二】找到 39890 进程中最消耗 cpu 的线程 top -d 1 -Hp 39890 得到最耗 CPU 的进程为 39900 【步骤二】将 PID 转换为十六进制 我们拿到了进程 PID 为：39900我们需要将它转为十六进制，才能进行后续指令操作printf “%x\\n” 39900得到结果：9bdc 【步骤三】打印当前线程的栈信息，看看它到底在干嘛 jstack 39890 | grep ‘9bdc’ -C5 现在已经找到了线程的栈信息，我看到了我自己写的代码，我用红框标记出来了 【步骤四】带着疑问去找代码 我们根据栈信息，直接在我们项目上定位到了那段代码 我发现，这里有一个死循环，我擦，忘记加休眠时间了，导致一直在死循环跑呢，终于找到问题根源了，加上了休眠时间，然后本地测试了下没问题； 关键这是线上的问题，得要赶紧上线啊，但是也得测试呢，我不得不拨通了小红（测试小姐姐）的电话，嘀。嘀。嘀。，我心里也在滴滴滴，这么早打电话给她让她测试，免不了被训，我已经做好了心里准备了，咦，通了： 小红：干啥？（测试小姐姐总是这么彪悍） 我：有有有一个小小的线上问题(说话已经开始紧张了，生怕她开骂，哈哈)，我已经改好了，需要你测试下，然后抓紧上线。 小红：今天不是周末么，还要测试，让不让人睡觉了啊？ 我：我我。。。，小姐姐，你长得这么可爱，美丽，端庄，温柔，贤惠，就帮忙测试下么，不然我这个月绩效又要被扣了… 小红：看你这么诚实，这次就勉强帮你测试下吧，但是下次不要在周末给我发提测了。 我：好的呢，下…(对方已经挂断了电话…) 哈哈，不管咋样，现在已经没我的事了，我合上电脑，又进入了梦乡… 全剧终经历了一次线上 bug 排查，让我胆战心惊，不过这次也给我增加了不少经验，毕竟重拾了 九阴正经，让我内功又增强了；后期会发布更多在实战方面的工作经验，与大家分享，希望大家能够喜欢，现在我需要你们的一键三连，哈哈，下期见。","categories":[],"tags":[]},{"title":"5年老java开发，我看过哪些书，看过哪些视频，刷过哪些面试题，都在这里了","slug":"yuque/5年老java开发，我看过哪些书，看过哪些视频，刷过哪些面试题，都在这里了","date":"2021-02-27T09:40:32.000Z","updated":"2021-02-28T14:18:34.369Z","comments":true,"path":"2021/02/27/yuque/5年老java开发，我看过哪些书，看过哪些视频，刷过哪些面试题，都在这里了/","link":"","permalink":"http://example.com/2021/02/27/yuque/5%E5%B9%B4%E8%80%81java%E5%BC%80%E5%8F%91%EF%BC%8C%E6%88%91%E7%9C%8B%E8%BF%87%E5%93%AA%E4%BA%9B%E4%B9%A6%EF%BC%8C%E7%9C%8B%E8%BF%87%E5%93%AA%E4%BA%9B%E8%A7%86%E9%A2%91%EF%BC%8C%E5%88%B7%E8%BF%87%E5%93%AA%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86/","excerpt":"","text":"1234tags: [面试,资料]categories: 面试--- 本篇文章没有任何水文，全是干货 作为 5 年开发工程师，拥有 5 年一线大厂的开发经验； 在大学就开始自学 java，在这期间有迷茫过，也想放弃过，但是最后都坚持了下来； 现在我把我自己一路走来珍藏的资料和学习方法都分享给大家，谨献给有需要的和准备涉及此行业的同学。 关注公众号“AI 码师”,公众号内回复“5 年”，可免费领取资料 电子书籍大概 2.5g；视频教程大概 7.3g； 电子书籍JAVA 入门必备 并发编程 分布式 微服务 数据库 阿里技术图册 数据结构与算法 2021 最新面试资料（四套） 视频架构师教程","categories":[],"tags":[]},{"title":"趣味编程｜手写一个集成多数据源mongodb的 starter","slug":"yuque/趣味编程｜手写一个集成多数据源mongodb的 starter","date":"2021-02-27T08:50:31.000Z","updated":"2021-02-28T14:18:34.469Z","comments":true,"path":"2021/02/27/yuque/趣味编程｜手写一个集成多数据源mongodb的 starter/","link":"","permalink":"http://example.com/2021/02/27/yuque/%E8%B6%A3%E5%91%B3%E7%BC%96%E7%A8%8B%EF%BD%9C%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E9%9B%86%E6%88%90%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90mongodb%E7%9A%84%20starter/","excerpt":"","text":"关注公众号“AI 码师”领取 2021 最新面试资料一份，公众号内回复“源码”，获取本项目源码 【前言】主演：老王(技术总监)，小码（本猿） 老王：小码啊，我们项目中需要使用到 mongodb，你集成下吧，完成了和我说下。 小码：好的，一会就给你弄好。 小码三下五除二的给集成好了，然后给老王汇报了。 小码：王哥，我已经把 mongodb 集成好了。 老王：好的，现在由于我们项目中会用到很多 mongo 数据库，你现在集成的 mongo 支持多数据源动态切换么？ 小码：这个，这个，啥叫多数据源动态切换啊？ 老王：就是在运行过程中，能够根据需要动态去连接哪个数据库，咱们项目需要支持多个特性，如果你对这个不太清楚的话，我给你一个思路，你可以考虑使用切面来实现，具体怎么弄，你自己研究下. 小码：好的，王哥。 小码想了很久，各种百度，终于找到了解决方案，花了一上午的时间，终于弄完了，又去给老王汇报了。 小码：王哥，现在项目中的 mongo 已经实现了多数据源了（哈哈，心里很自豪）。 老王：小伙子，很快嘛，不过现在又来一个任务，你需要把你集成的这个功能封装成一个 starter，另外一个项目也需要使用这个功能，你抽时间封装下吧。 小码：好的，王哥，保证完成任务 小码下去之后，就开始研究怎么去封装成一个 starter，下班之前弄好了，不过这次他没去找老王了，准备第二天再去，不然又得加班，哈哈！！！ 【正文】前面水了那么多，主要是给大家设置一种场景，让同志们知道为啥要去做这么一个功能，现在就直接进入正题了： 【springboot 集成 mongodb】 引入 mongodb 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 配置 mongodb 连接信息，在 application.yml 中配置 12345678910# 设置了用户名和密码的连接spring: data: mongodb: uri: mongodb:&#x2F;&#x2F;用户名:密码@IP:PORT&#x2F;数据库?authSource&#x3D;$&#123;auth_db:用户认证数据库&#125;# 没有设置用户名和密码的连接配置spring: data: mongodb: uri: mongodb:&#x2F;&#x2F;IP:PORT&#x2F;数据库 写测试代码 我们创建一个接口，然后在接口方法中去操作 monog 库: 接口中，直接引入 MongoTemplate，就可以直接操作 mongo 了，这里对 mongo 如何使用不做过多介绍。 1234567891011121314151617181920&#x2F;** * Created by AI码师 on 2019&#x2F;4&#x2F;19. * 关注公众号【AI码师】领取2021最新面试资料一份（很全） * @return *&#x2F;@RequestMapping(&quot;&#x2F;home&quot;)@RestControllerpublic class HomeController &#123; @Autowired private MongoTemplate mongoTemplate; @PostMapping public String addData(@RequestParam(value &#x3D; &quot;name&quot;) String name,@RequestParam(value &#x3D; &quot;addr&quot;) String addr,@RequestParam(value &#x3D; &quot;email&quot;) String email)&#123; Student student &#x3D; new Student(); student.setAddr(addr); student.setName(name); student.setEmail(email); mongoTemplate.insert(student); return &quot;添加成功&quot;; &#125;&#125; 请求接口： 响应数据： 响应添加成功，我们看下数据库，是否添加上去了： 数据已经添加上去了，说明已经集成成功了，但这还是第一步，我们需要做的是支持多数据源，接下来我们一起来完成逼格更高的多数据源 mongo 吧。 【实现多数据源】实现思路先介绍下实现多数据源动态切换的思路： 首先通过 AOP 技术，在调用方法前后动态替换 mongo 数据源，这个主要是替换 mongo 中 mongodbfactory(SimpleMongoClientDatabaseFactory)值,每个 factory 都维护自己需要连接的库，如果在操作之前，替换该参数为自己需要操作的数据库 factory，操作结束又切换成原来的，不就可以实现动态切换数据源了么。 说完了思路，我们直接上代码吧 垒代码 添加 aop 依赖 12345&lt;!--引入AOP依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 修改数据库连接配置 123456789101112# 设置了用户名和密码的连接spring: data: mongodb: uri: mongodb:&#x2F;&#x2F;用户名:密码@IP:PORT&#x2F;#?authSource&#x3D;$&#123;auth_db:用户认证数据库&#125;# 没有设置用户名和密码的连接配置spring: data: mongodb: uri: mongodb:&#x2F;&#x2F;IP:PORT&#x2F;#与上述配置，做了小小的改动，将操作的数据库名称替换成了#，用来做后续备用 创建切面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.aimashi.dynamicmongo.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.data.mongodb.core.MongoDatabaseFactorySupport;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.SimpleMongoClientDatabaseFactory;import org.springframework.stereotype.Component;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;&#x2F;** * Created by AI码师 on 2019&#x2F;4&#x2F;19. * 关注公众号【AI码师】领取2021最新面试资料一份（很全） * @return *&#x2F;@Component@Aspectpublic class MongoSwitch &#123; private final Logger logger &#x3D; LoggerFactory.getLogger(MongoSwitch.class); @Autowired private MongoDatabaseFactorySupport mongoDbFactory; private final Map&lt;String, MongoDatabaseFactorySupport&gt; templateMuliteMap &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F; 获取配置文件的副本集连接 @Value(&quot;$&#123;spring.data.mongodb.uri&#125;&quot;) private String uri; &#x2F;&#x2F; @Pointcut(&quot;@annotation(com.pig4cloud.pig.common.log.annotation.MongoLog)&quot;) @Pointcut(&quot;execution(public * com.aimashi.dynamicmongo.config.MongotemplteService.*(..))&quot;) public void routeMongoDB() &#123;&#125; @Around(&quot;routeMongoDB()&quot;) public Object routeMongoDB(ProceedingJoinPoint joinPoint) &#123; Object result &#x3D; null; &#x2F;&#x2F; 获取需要访问的项目数据库 String dbName &#x3D; (String) joinPoint.getArgs()[0]; Object o &#x3D; joinPoint.getTarget(); Field[] fields &#x3D; o.getClass().getDeclaredFields(); MultiMongoTemplate mongoTemplate &#x3D; null; try &#123; for (Field field : fields) &#123; field.setAccessible(true); Class fieldclass &#x3D; field.getType(); &#x2F;&#x2F; 找到Template的变量 if (fieldclass &#x3D;&#x3D; MongoTemplate.class || fieldclass &#x3D;&#x3D; MultiMongoTemplate.class) &#123; &#x2F;&#x2F; 查找项目对应的MongFactory SimpleMongoClientDatabaseFactory simpleMongoClientDbFactory &#x3D; null; &#x2F;&#x2F; 实例化 if (templateMuliteMap.get(dbName) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 替换数据源 simpleMongoClientDbFactory &#x3D; new SimpleMongoClientDatabaseFactory(this.uri.replace(&quot;#&quot;, dbName)); templateMuliteMap.put(dbName, simpleMongoClientDbFactory); &#125; else &#123; simpleMongoClientDbFactory &#x3D; (SimpleMongoClientDatabaseFactory) templateMuliteMap.get(dbName); &#125; &#x2F;&#x2F; 如果第一次，赋值成自定义的MongoTemplate子类 if (fieldclass &#x3D;&#x3D; MongoTemplate.class) &#123; mongoTemplate &#x3D; new MultiMongoTemplate(simpleMongoClientDbFactory); &#125; else if (fieldclass &#x3D;&#x3D; MultiMongoTemplate.class) &#123; Object fieldObject &#x3D; field.get(o); mongoTemplate &#x3D; (MultiMongoTemplate) fieldObject; &#125; &#x2F;&#x2F; 设置MongoFactory mongoTemplate.setMongoDbFactory(simpleMongoClientDbFactory); &#x2F;&#x2F; 重新赋值 field.set(o, mongoTemplate); break; &#125; &#125; try &#123; result &#x3D; joinPoint.proceed(); &#x2F;&#x2F; 清理ThreadLocal的变量 mongoTemplate.removeMongoDbFactory(); &#125; catch (Throwable t) &#123; logger.error(&quot;&quot;, t); mongoTemplate.removeMongoDbFactory(); &#125; &#125; catch (Exception e) &#123; logger.error(&quot;&quot;, e); &#125; return result; &#125;&#125; 创建相关配置类 12345678910111213141516package com.aimashi.dynamicmongo.config;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.stereotype.Service;&#x2F;** * Created by AI码师 on 2019&#x2F;4&#x2F;19. * 关注公众号【AI码师】领取2021最新面试资料一份（很全） * @return *&#x2F;@Servicepublic class MongotemplteService &#123; private MongoTemplate mongoTemplate; public &lt;T&gt; T save(String dbName, T var1) &#123; return mongoTemplate.save(var1); &#125;&#125; 1234567891011121314151617181920212223242526272829303132package com.aimashi.dynamicmongo.config;import com.mongodb.client.MongoDatabase;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.data.mongodb.core.MongoDatabaseFactorySupport;import org.springframework.data.mongodb.core.MongoTemplate;public class MultiMongoTemplate extends MongoTemplate &#123; private Logger logger&#x3D; LoggerFactory.getLogger(MultiMongoTemplate.class);&#x2F;&#x2F;用来缓存当前MongoDbFactory private static ThreadLocal&lt;MongoDatabaseFactorySupport&gt; mongoDbFactoryThreadLocal; public MultiMongoTemplate(MongoDatabaseFactorySupport mongoDbFactory)&#123; super(mongoDbFactory); if(mongoDbFactoryThreadLocal&#x3D;&#x3D;null) &#123; mongoDbFactoryThreadLocal &#x3D; new ThreadLocal&lt;&gt;(); &#125; &#125; public void setMongoDbFactory(MongoDatabaseFactorySupport factory)&#123; mongoDbFactoryThreadLocal.set(factory); &#125; public void removeMongoDbFactory()&#123; mongoDbFactoryThreadLocal.remove(); &#125; @Override public MongoDatabase getDb() &#123; return mongoDbFactoryThreadLocal.get().getMongoDatabase(); &#125;&#125; 添加测试接口 123456789101112131415&#x2F;** * Created by AI码师 on 2019&#x2F;4&#x2F;19. * 关注公众号【AI码师】领取2021最新面试资料一份（很全） * @return *&#x2F;&#x2F;&#x2F; dbName 为数据库名称 @PutMapping public String addDataByDynamic(@RequestParam(value &#x3D; &quot;dbName&quot;) String dbName,@RequestParam(value &#x3D; &quot;name&quot;) String name,@RequestParam(value &#x3D; &quot;addr&quot;) String addr,@RequestParam(value &#x3D; &quot;email&quot;) String email)&#123; Student student &#x3D; new Student(); student.setAddr(addr); student.setName(name); student.setEmail(email); mongotemplteService.insert(dbName,student); return &quot;添加成功&quot;; &#125; 请求接口：数据库名参数传了 ams1 请求响应：响应成功 我们看下数据库，发现在数据库 ams1 下面已经有了此数据： 我们将数据库名参数修改为：ams2，进行请求 发现数据源已经切换成功了。 到这里，大家有没有发现自己很牛逼了啊，不过本篇文章还没算完，现在虽然已经实现了动态切换数据源的功能，但是还只能在自己项目上用，别的项目需要使用，只能直接复制过去，我们接下来需要做一个更牛逼的事情：手写一个 starter 来封装这个功能，别人只需要引入依赖，即可开箱即用： 【整合到 starter 里面】 创建一个 maven 项目：dynamicmongo-starter 将如下文件拷贝到新项目中 创建自动装配文件 1234567891011121314151617181920212223package com.aimashi.dynamicmongo.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;&#x2F;** * Created by AI码师 on 2019&#x2F;4&#x2F;19. * 关注公众号【AI码师】领取2021最新面试资料一份（很全） * @return *&#x2F;@Configuration(proxyBeanMethods &#x3D; false)public class MongodbAutoConfiguration &#123; @Bean public MongoSwitch mongoSwitch() &#123; return new MongoSwitch(); &#125; @Bean public MongotemplteService mongotemplteService() &#123; return new MongotemplteService(); &#125;&#125; 新建 resources/META_INF/spring.factories 文件 12org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\ com.aimashi.dynamicmongo.config.MongodbAutoConfiguration 到这里 starter 已经编写完成，是不是很简单。。 【使用 starter】starter 已经编写好，我们只需要在项目中引入该依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.aimashi&lt;&#x2F;groupId&gt; &lt;artifactId&gt;dynamicmongo-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 然后在需要操作 mongod 方法的地方，引入：MongotemplteService 即可； 注意 MongotemplteService 里面的方法大家按需扩充，目前只写了一个，大家使用的时候，只需要把 mongoTemplate 里面的方法名写到 MongotemplteService 中，然后再去调用 mongoTemplate 里面对应方法即可。 【总结】很少写这么长的实践类文章，现在已经十一点半了，该休息了，后面会有更多文章和大家一起分享，希望大家能有所收获，晚安！","categories":[],"tags":[]},{"title":"工作经验｜lambada处理集合的常用10种实战骚操作，我都记录下来了","slug":"yuque/工作经验｜lambada处理集合的常用10种实战骚操作，我都记录下来了","date":"2021-02-27T06:54:08.000Z","updated":"2021-02-28T14:18:34.505Z","comments":true,"path":"2021/02/27/yuque/工作经验｜lambada处理集合的常用10种实战骚操作，我都记录下来了/","link":"","permalink":"http://example.com/2021/02/27/yuque/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%EF%BD%9Clambada%E5%A4%84%E7%90%86%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A810%E7%A7%8D%E5%AE%9E%E6%88%98%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%88%91%E9%83%BD%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%9D%A5%E4%BA%86/","excerpt":"","text":"关注公众号“AI 码师”领取 2021 最新面试资料一份，公众号内回复“源码”，获取本项目源码 最近在项目上面经常使用 lambada 表达式，但是总是记不住，一直都在百度，写完之后就忘记了，感觉很费时间；这次就花点时间，把一些常用的 lambada 处理集合的实例都保存了下来(去重，分组，求和，list 转 map 等等)，以后就不用到处找了，刚好也可以给同学们分享下；另外也把一些关于使用 lambada 时遇到的坑也给大家一起分享下，所有代码拿来即用！！！本文档持续更新… 实例演示商品实体 12345678@Data@AllArgsConstructorpublic class GoodInfo &#123; private String mallSource; private String skuNo; private int price; private int monthCount;&#125; 排序集合排序在项目中用的频率还蛮高，这里以按照销量排序为例 123456789101112List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList(); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000)); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10)); &#x2F;&#x2F; 按照销量正序 从小到大排序 goodInfos.sort(Comparator.comparing(GoodInfo::getMonthCount)); &#x2F;&#x2F; 按照销量倒序 从大到小排序 goodInfos.sort(Comparator.comparing(GoodInfo::getMonthCount).reversed()); 取最大值/取最小值/求和12345678910111213141516List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 获取最大销量 注意如果求最大值是在filter之后使用例如，goodInfos.stream().filter().max一定要判断filter后集合数量是否不为空，否则使用max的get方法会报错GoodInfo hotGoodInfo &#x3D; goodInfos.stream().max(Comparator.comparing(GoodInfo::getMonthCount)).get();&#x2F;&#x2F; 求最低价格商品GoodInfo lowPriceGoodInfo &#x3D; goodInfos.stream().min(Comparator.comparing(GoodInfo::getMonthCount)).get();&#x2F;&#x2F; 计算商品总价格int sum &#x3D; goodInfos.stream().mapToInt(person -&gt; person.getPrice()).sum();&#x2F;&#x2F; 求平均价格double avg &#x3D; goodInfos.stream().mapToInt(person -&gt; person.getPrice()).average().getAsDouble(); 遍历12345678910111213List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList(); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000)); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10)); &#x2F;&#x2F; 遍历输出所有商品id goodInfos.forEach( goodInfo -&gt; &#123; System.out.println(goodInfo.getSkuNo()); &#125;); 实体集合 转 单个属性的集合往往在我们项目中会有这样的需求：我需要提取集合中某一个属性，然后组装成集合，通常做法是先创建一个字符串集合，然后遍历原始集合，取出数据，放到字符串集合中，虽然也能实现功能，但是不免太过于繁琐，现在使用一行 lambada 表达式即可搞定： 12345678910List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 将list转为某个属性map 这里是把所有skuno全部取出来 作为集合List&lt;String&gt; skuNos &#x3D; goodInfos.stream().map(goodInfo -&gt; goodInfo.getSkuNo()).collect(Collectors.toList()); 实体集合 转 map 返回12345678910List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 将list转为map，key 为商品idMap&lt;String, GoodInfo&gt; map &#x3D; goodInfos.stream().collect(Collectors.toMap(GoodInfo::getSkuNo, goodInfo -&gt; goodInfo)); 实体集合按照某个属性分组12345678910List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 按照商品来源分组Map&lt;String, List&lt;GoodInfo&gt;&gt; map &#x3D; goodInfos.stream().collect(Collectors.groupingBy(GoodInfo::getMallSource)); 过滤数据（记得接收）12345678910111213141516171819List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 过滤商品价格大于300的&#x2F;&#x2F; todo 过滤后一定要使用集合接收，否则等于没有过滤List&lt;GoodInfo&gt; collect &#x3D; goodInfos.stream() .filter(goodInfo -&gt; goodInfo.getPrice() &gt; 300) .collect(Collectors.toList());collect.forEach( goodInfo -&gt; &#123; System.out.println(goodInfo.getPrice()); &#125;); 去重(两种方法可选)方法一 set 去重1234567891011121314151617List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 使用treeset 集合来实现去重，这里一定要使用集合接收，不然等于没有去重List&lt;GoodInfo&gt; goodInfos1 &#x3D; goodInfos.stream() .collect( Collectors.collectingAndThen( Collectors.toCollection( () -&gt; new TreeSet&lt;&gt;(Comparator.comparing(o -&gt; o.getSkuNo()))), ArrayList::new)); 方法二 map 去重123456789101112131415161718192021public static void main(String[] args) &#123; List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList(); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000)); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10)); &#x2F;&#x2F; 使用map去重 List&lt;GoodInfo&gt; goodInfos2 &#x3D; goodInfos.stream() .filter(distinctByKey(goodInfo -&gt; goodInfo.getSkuNo())) .collect(Collectors.toList()); &#125; public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, ?&gt; keyExtractor) &#123; Map&lt;Object, Boolean&gt; seen &#x3D; new ConcurrentHashMap&lt;&gt;(); return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) &#x3D;&#x3D; null; &#125; 遇到的坑坑一 报错信息：java.util.NoSuchElementException: No value present 解决方案：一般出现这个错都是在 filter 操作后面使用了 max/min 等操作，然后调用了 get 方法，取不到数据，导致报错，所以建议检查 filter 操作后时候还有数据，有数据再进行后续操作： 1234 Optional&lt;User&gt; optional &#x3D; goodInfos.stream().max(userComparator);if(optional !&#x3D; null &amp;&amp; optional.isPresent()) &#123; recentUserServer &#x3D; optional.get().getServer();&#125; 坑二 使用了 filter 为什么没起作用呢？ 调用 filter 之后，它是有返回值的，所以你需要使用新的集合去接收 。。。 后续慢慢填坑","categories":[],"tags":[]}],"categories":[],"tags":[]}