{"meta":{"title":"AI码师","subtitle":"授人以鱼不如授人以渔","description":"拥有五年一线大厂开发经验，擅长分布式、微服务、性能调优、源码分析、并发编程、面试经验分享等众多技能,关注公众号“AI码师”领取2021最新面试资料一份","author":"AI码师","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-02-27T08:19:34.261Z","updated":"2021-02-27T08:19:34.261Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-02-27T08:19:34.265Z","updated":"2021-02-27T08:19:34.265Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-02-27T08:19:34.265Z","updated":"2021-02-27T08:19:34.265Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-02-27T08:19:34.265Z","updated":"2021-02-27T08:19:34.265Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-02-27T08:19:34.265Z","updated":"2021-02-27T08:19:34.265Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-02-27T08:19:34.265Z","updated":"2021-02-27T08:19:34.265Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-02-27T08:19:34.265Z","updated":"2021-02-27T08:19:34.265Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-02-27T08:19:34.261Z","updated":"2021-02-27T08:19:34.261Z","comments":true,"path":"2021/02/27/hello-world/","link":"","permalink":"http://example.com/2021/02/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"关于我","slug":"yuque/关于我","date":"2021-02-27T08:13:21.000Z","updated":"2021-02-27T08:20:03.838Z","comments":true,"path":"2021/02/27/yuque/关于我/","link":"","permalink":"http://example.com/2021/02/27/yuque/%E5%85%B3%E4%BA%8E%E6%88%91/","excerpt":"","text":"自语 大家好，我是一枚会前端的后端开发工程师 👨🏻‍💻，目前主攻 Java 后端开发. 我希望用代码改变世界,我也在改变世界,自豪脸 😏 目前正走在成为一个厉害(Zhuang Bi)程序猿的路上. 前途很艰辛, 但是我会坚持! 生活不止有撸码和工作, 也有诗和远方. 在快乐中生活, 在快乐中工作, 爱家人, 爱自己 子曰：生而知之者，上也；学而知之者，次也；困而学之，又其次也；困而不学，民斯为下矣。人生得意须尽欢，莫使金樽空对月。少小须勤学，文章可立身。满朝朱紫贵，尽是读书人。 技能 语言：Java, JavaScript, HTML, CSS 数据库：MySQL, Redis, Oracle 开发框架：Spring, Spring Boot, Spring Cloud, MyBatis, Guice, Shiro, React, JQuery，Bootstrap 中间件：Kafka, Zookeeper 构建工具： Maven, Tomcat 环境： Mac, Ubuntu, Linux, Git, Intellij IDEA 学习 有道是学无止境，Java 后端开发的路很难走，但是既然走了这条路，那就得一直走下去。 Java 相关的技术栈很多，学起来很不容易，最近两年的行情也是优胜劣汰，希望自己能够快速成长起来 夯实基础，学习源码 今年想要学习一下 python 博客 期望：平时生活和工作一种记录, 希望之后回过头再来看自己的博客也会有所收获或感想 技术、电影与生活 对生活和学习的一个记录 希望自己越来越强大，越来越开心 免责声明 本站所有文章为了记录工作、学习中遇到的问题，可能由于本人技术有限，有些不正确的地方，仅供参考 本站文章引用或转载写明来源，感谢原作者的辛苦写作，如果有异议或侵权，及时联系我处理，谢谢！ 如他人引用本站中的文章或内容，请注明出处。但其文章或内容已不是本人原本的意思，请各位注意辨别！ 本站所有文章仅代表个人当时意见和想法 欢迎指出有问题的地方，我会尽快修正，谢谢！ 内容转载请保留署名以及原文连接，谢谢? 本网站所有作品采用 知识共享署名-相同方式共享 4.0 国际许可协议 进行许可。 关注我关注公众号“AI 码师”领取 2021 最新面试资料一份","categories":[],"tags":[]},{"title":"工作经验｜lambada处理集合的常用10种实战骚操作，我都记录下来了","slug":"yuque/工作经验｜lambada处理集合的常用10种实战骚操作，我都记录下来了","date":"2021-02-27T06:54:08.000Z","updated":"2021-02-27T08:20:03.878Z","comments":true,"path":"2021/02/27/yuque/工作经验｜lambada处理集合的常用10种实战骚操作，我都记录下来了/","link":"","permalink":"http://example.com/2021/02/27/yuque/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%EF%BD%9Clambada%E5%A4%84%E7%90%86%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A810%E7%A7%8D%E5%AE%9E%E6%88%98%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%88%91%E9%83%BD%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%9D%A5%E4%BA%86/","excerpt":"","text":"关注公众号“AI 码师”领取 2021 最新面试资料一份，公众号内回复“源码”，获取本项目源码 最近在项目上面经常使用 lambada 表达式，但是总是记不住，一直都在百度，写完之后就忘记了，感觉很费时间；这次就花点时间，把一些常用的 lambada 处理集合的实例都保存了下来(去重，分组，求和，list 转 map 等等)，以后就不用到处找了，刚好也可以给同学们分享下；另外也把一些关于使用 lambada 时遇到的坑也给大家一起分享下，所有代码拿来即用！！！本文档持续更新… 实例演示商品实体 12345678@Data@AllArgsConstructorpublic class GoodInfo &#123; private String mallSource; private String skuNo; private int price; private int monthCount;&#125; 排序集合排序在项目中用的频率还蛮高，这里以按照销量排序为例 123456789101112List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList(); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000)); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10)); &#x2F;&#x2F; 按照销量正序 从小到大排序 goodInfos.sort(Comparator.comparing(GoodInfo::getMonthCount)); &#x2F;&#x2F; 按照销量倒序 从大到小排序 goodInfos.sort(Comparator.comparing(GoodInfo::getMonthCount).reversed()); 取最大值/取最小值/求和12345678910111213141516List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 获取最大销量 注意如果求最大值是在filter之后使用例如，goodInfos.stream().filter().max一定要判断filter后集合数量是否不为空，否则使用max的get方法会报错GoodInfo hotGoodInfo &#x3D; goodInfos.stream().max(Comparator.comparing(GoodInfo::getMonthCount)).get();&#x2F;&#x2F; 求最低价格商品GoodInfo lowPriceGoodInfo &#x3D; goodInfos.stream().min(Comparator.comparing(GoodInfo::getMonthCount)).get();&#x2F;&#x2F; 计算商品总价格int sum &#x3D; goodInfos.stream().mapToInt(person -&gt; person.getPrice()).sum();&#x2F;&#x2F; 求平均价格double avg &#x3D; goodInfos.stream().mapToInt(person -&gt; person.getPrice()).average().getAsDouble(); 遍历12345678910111213List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList(); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000)); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10)); &#x2F;&#x2F; 遍历输出所有商品id goodInfos.forEach( goodInfo -&gt; &#123; System.out.println(goodInfo.getSkuNo()); &#125;); 实体集合 转 单个属性的集合往往在我们项目中会有这样的需求：我需要提取集合中某一个属性，然后组装成集合，通常做法是先创建一个字符串集合，然后遍历原始集合，取出数据，放到字符串集合中，虽然也能实现功能，但是不免太过于繁琐，现在使用一行 lambada 表达式即可搞定： 12345678910List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 将list转为某个属性map 这里是把所有skuno全部取出来 作为集合List&lt;String&gt; skuNos &#x3D; goodInfos.stream().map(goodInfo -&gt; goodInfo.getSkuNo()).collect(Collectors.toList()); 实体集合 转 map 返回12345678910List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 将list转为map，key 为商品idMap&lt;String, GoodInfo&gt; map &#x3D; goodInfos.stream().collect(Collectors.toMap(GoodInfo::getSkuNo, goodInfo -&gt; goodInfo)); 实体集合按照某个属性分组12345678910List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 按照商品来源分组Map&lt;String, List&lt;GoodInfo&gt;&gt; map &#x3D; goodInfos.stream().collect(Collectors.groupingBy(GoodInfo::getMallSource)); 过滤数据（记得接收）12345678910111213141516171819List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 过滤商品价格大于300的&#x2F;&#x2F; todo 过滤后一定要使用集合接收，否则等于没有过滤List&lt;GoodInfo&gt; collect &#x3D; goodInfos.stream() .filter(goodInfo -&gt; goodInfo.getPrice() &gt; 300) .collect(Collectors.toList());collect.forEach( goodInfo -&gt; &#123; System.out.println(goodInfo.getPrice()); &#125;); 去重(两种方法可选)方法一 set 去重1234567891011121314151617List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList();goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000));goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100));goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1));goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10));&#x2F;&#x2F; 使用treeset 集合来实现去重，这里一定要使用集合接收，不然等于没有去重List&lt;GoodInfo&gt; goodInfos1 &#x3D; goodInfos.stream() .collect( Collectors.collectingAndThen( Collectors.toCollection( () -&gt; new TreeSet&lt;&gt;(Comparator.comparing(o -&gt; o.getSkuNo()))), ArrayList::new)); 方法二 map 去重123456789101112131415161718192021public static void main(String[] args) &#123; List&lt;GoodInfo&gt; goodInfos &#x3D; Arrays.asList(); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_1112312312&quot;, 199, 100000)); goodInfos.add(new GoodInfo(&quot;tb&quot;, &quot;tb_23534231231&quot;, 399, 10)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_1110080098&quot;, 299, 100)); goodInfos.add(new GoodInfo(&quot;jd&quot;, &quot;jd_412313123&quot;, 99, 10000000)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_354532431&quot;, 599, 1)); goodInfos.add(new GoodInfo(&quot;pdd&quot;, &quot;pdd_1423124131&quot;, 499, 10)); &#x2F;&#x2F; 使用map去重 List&lt;GoodInfo&gt; goodInfos2 &#x3D; goodInfos.stream() .filter(distinctByKey(goodInfo -&gt; goodInfo.getSkuNo())) .collect(Collectors.toList()); &#125; public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, ?&gt; keyExtractor) &#123; Map&lt;Object, Boolean&gt; seen &#x3D; new ConcurrentHashMap&lt;&gt;(); return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) &#x3D;&#x3D; null; &#125; 遇到的坑坑一 报错信息：java.util.NoSuchElementException: No value present 解决方案：一般出现这个错都是在 filter 操作后面使用了 max/min 等操作，然后调用了 get 方法，取不到数据，导致报错，所以建议检查 filter 操作后时候还有数据，有数据再进行后续操作： 1234 Optional&lt;User&gt; optional &#x3D; goodInfos.stream().max(userComparator);if(optional !&#x3D; null &amp;&amp; optional.isPresent()) &#123; recentUserServer &#x3D; optional.get().getServer();&#125; 坑二 使用了 filter 为什么没起作用呢？ 调用 filter 之后，它是有返回值的，所以你需要使用新的集合去接收 。。。 后续慢慢填坑","categories":[],"tags":[]}],"categories":[],"tags":[]}